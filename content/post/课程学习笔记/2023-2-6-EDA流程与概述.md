---
# 常用定义
title: "EDA流程与概述"
date: 2023-04-29    # 创建时间
lastmod: 2023-04-29 # 最后修改时间
draft: false                       # 是否是草稿？
tags: ["Notes", "EDA", "开发"]  # 标签
categories: ["EDA"]     # 分类
author: "李尚坤"                  # 作者

# 用户自定义
# 你可以选择 关闭(false) 或者 打开(true) 以下选项
comment: false   # 关闭评论
toc: true       # 关闭文章目录
# 你同样可以自定义文章的版权规则
contentCopyright: '<a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a>'
reward: false	 # 关闭打赏
mathjax: true    # 打开 mathjax
---

# EDA流程与概述

这一系列笔记主要是我学习知乎答主格律的文章的记录

强烈推荐阅读他的文章，我的记录只是根据我自己的理解写下的，方便我日后回顾

[设计VLSI EDA](https://zhuanlan.zhihu.com/p/380962676)

---

# Chapter0 EDA的What, Why, How

## 1 What：VLSI EDA是什么

将非常复杂的电子电路塞到一块很小的芯片上，直接靠人力显然是很难实现的。因此我们使用计算机辅助设计(Compuer -Aided Design, CAD)进行电路设计。然后通过计算机算法，把在软件上设计好的电路映射到芯片上，就得到了我们想要的芯片。

## 2 Why&How：为什么要用EDA，及其内部的原理

### 2.1 设计芯片规格

这主要是上层的设计，还不涉及到coding的环节。需要设计出CPU的框架、功能、模块划分等等，包括以下几个部分

1. 指令集架构：比如x86、ARM、RISC-V架构。比如一些EDA软件（Cadence的Tensilica SDK、Synopsis CEVA）支持自定义新的指令，并把这些定制指令整合到已有CPU处理器中
2. 微系统架构：主要是硬件架构方面，如芯片的内部系列组件（GIB、IOB、PE等等）

做好了这些设计，需要进行系统级（system level）的仿真，或者行为级（behavioral）的仿真。以此来验证这个上层设计合不合理，性能、功耗、面积（PPA指标，Power-Performance-Area）如何。常用的系统级仿真器有gem5

### 2.2 硬件设计描述

在上层设计及仿真都没啥问题之后，我们就可以开始coding了，这一部分就主要是通过写HDL代码来进行具体的设计。

在这一个环节中，EDA工具作用体现在两个方面

#### 2.2.1 设计库的高效、灵活重用

比如这段时间RISC-V的提出，重新吸引力人们对于架构的关心。在进行RISC-V架构设计的过程中，提出了Chisel语言。Chisel可以让我们在更高、更抽象的层面进行设计，然后利用chisel的框架参数化地生成verilog代码，大大减少了在底层代码上花费的时间。

#### 2.2.2 高层次综合

这就是利用C++、Python这些语言进行硬件设计，利用编译器将这些代码转换为低层次的语言，比如Verilog/VHDL等。算法其实就是Control Flow+Data Flow，所以可以按照某些规则将Control Flow转换成有限状态机，将Data Flow转换成由寄存器与运算逻辑构成的数据通路。

目前商用的HLS工具有Xilinx Vitis HLS、Intel HLS，学术界开源的有LegUp、BamBu、GAUT

**HLS流程概述**：一共分为前端、中端与后端。

1. 前端：解析高层次语言，生成AST，再转换成IR
2. 中端：对IR、DFG进行优化
3. 后端：将优化好的DFG转换为FSM+Datapath，即把**调度**（把各个操作映射到不同的时钟周期内，实现不同颗粒度的流水线）与**资源绑定**（把各个操作映射到运算资源上面）

### 2.3 针对功能验证的设计

在完成HDL的书写之后，需要对其进行功能性的进行验证，以验证我们的HDL写得没有问题，能够完成我们的目标工作

主要就是行为级验证（Functional Verification）

#### 2.3.1 基于仿真的验证

##### 2.3.1.1 给设计的外部信号咋来的？

这一外部信号主要是由验证平台产生的，比如UVM(Universal Verification Methodology)。提高了验证的抽象层次，把验证功能模块化，把过程变成一个个事务（Transaction）。

##### 2.3.1.2 设计内部信号如何按照设计进行传递与变化

仿真器一般会将Verilog等RTL描述根据综合语法、行为规范翻译成C++代码。

比如不同的wire与reg对应C++中不同的数据类型与结构，module对应class。always块、表达式等可以映射为函数、运算表达式等。总之就可以理解为在针对功能的仿真中是将Verilog映射到C++中，用C++模拟出各种逻辑功能的实现。

#### 2.3.2 形式化验证

形式化验证大致分为形式模型检查（Formal Model Checking），等价性检查（Equivalence Checking），定理证明（Theory Proving)。主要是从**“理论上”**证明设计的功能。

1. 形式模型检查：将设计转换为数学表征的模型，然后利用模型检查工具遍历模型的状态集合，检查定义的形式规范是否一直被遵守
2. 等价性检查：一般用在综合、布局布线这些设计器件网表会被转化改变的时候。通过建立起两个待验证电路的BDD二叉决策树，利用一些算法比较他们是否相同
3. 定理证明：待补

### 2.4 逻辑综合

将RTL级描述转化为门级表达的过程，叫做逻辑综合。这一过程的一般目标是减少面积资源的需求、提高设计频率、降低功耗

#### 2.4.1 组合逻辑优化

也就是布尔逻辑式的最小化，找到最简单门级电路实现的布尔表达式。比如利用卡诺图化简等等

#### 2.4.2 时序逻辑优化

时序电路有最高频率的限制，通过Retiming算法可以移动寄存器在DAG（有向无环图）网表中的位置，从而有可能实现更高频的数字电路

#### 2.4.3 工艺映射

将RTL生成的逻辑行为网表与standard cell库中的元件进行组合、布局、连接，从而映射成一个个逻辑器件，最终变成门级网表。

### 2.5 物理综合

当有了门级网表之后，就需要把这些器件放在给定的芯片上了。这一部分就需要考虑更加细致的器件、工艺等实际因素了，这就是物理综合。

#### 2.5.1 布局

布局就是将逻辑综合生成的门级网表合理地排布在一个矩阵区域内。既要保证后续布线、工艺检查的可行性，又要考虑一系列评价指标

1. 全局布局：决定各器件在芯片上大致的位置，一般是以模块进行划分
2. 细致布局：不断进行迭代，逐渐进行优化（可以用模拟退火算法，分割网表的方法，解析法等）

#### 2.5.2 布线

将放置在板子上的芯片用线连接起来

1. 全局布线：将芯片划分为几个不同的区域，然后在不同区域之间连线
2. 细致布线：在全局布线的基础上，连接器件

# Chapter1 辅助架构设计与仿真中的EDA原理

## 1 架构的定义

这里的架构主要指的是SoC架构。这里面包括芯片系统中包含什么组件、组件之间怎么连接、如何进行交互这3个问题。

设计中需要考虑很多因素，这些因素会影响最终的收益与成本。因此目前架构设计中的难点主要有映射、评估分析以及高效自动化的设计空间探索。

## 2 系统功能、组件

首先根据需求和应用确定芯片的具体功能，这些功能将会决定大致需要哪些组件

1. 首先构思解决问题在软件层面的算法，如神经网络、机器学习、加密解密等
2. 然后对这些算法的控制流及数据流进行特征分析，如控制的模式、数据的颗粒度
3. 并非所有功能都要在硬件上实现，要对应用进行软硬协同设计，考虑哪些部分可以下放到硬件上处理，哪些保留在软件层面实现
4. 针对输入输出、硬件上的处理流程，对芯片进行模块化

### 2.1 应用特征分析

VLSI设计分为三类：计算密集型（算法中有大量的运算，需要经过较多处理后才会输出），数据密集型（数据处理链路很短/快，但是数据吞吐量>数据读写量，瓶颈在于数据读写带宽或数据利用率），控制密集型（计算量不多，但是有很多条件分支）

1. EDA静态分析：

   利用高性能应用编译器（CUDA，HLS编译器）的内置功能，把代码转为IR，对应用的控制流、数据流进行分析

2. EDA动态分析：

   通过一些测试输入，模拟/检测算法的运行过程

### 2.2 应用软硬件协同设计

软硬协同设计的第一部分是软硬件划分。本质上是将应用划分为通用处理器负责的部分与设计者定制的部分

软硬件划分可以分为细粒度（指令集）划分和粗颗粒度（函数、代码块）划分。

细粒度划分：可以分析源码发现其中的性能瓶颈语句，然后定制出指令替换掉源码，并将定制指令运行在协处理器（Co-Processor）中

粗粒度划分：展示各函数的调用频率，比较二者（在CPU与FPGA）实现效率，从而让设计者选定需要在FPGA上加速的函数

### 2.3 组件的选用与组件的通用、专用与定制

可以利用2.2中的EDA工具直接生成硬件模块。但一般为了追求更高性能，一般会人工设计。这一过程需要选用组件。部分组件是现成的，有的需要定制，这就是IP

组件类型的选取：一些组件要完成的功能较复杂多变，选用通用设计，如MCU；一些有特定功能，选专用设计；如果没有现成设计，需要定制

EDA工具可以协助设计者分析PPA，然后不断变换组件组合和参数，实现最优化，也就是设计空间探索

## 3 系统层次、拓扑与互动关联

层次是指模块与模块之间的包含关系；拓扑是针对同一层次中，各组件的连接关系；互动石河子组件之间的通讯形式与内容

### 3.1 运算、存储与通讯

由于系统中存储与运算模块一般是分离的，他们之间存在通讯，所以我们一般希望存储单元离运算单元越近越好。因此出现了多级缓存的设计，以及存内计算的设计

当系统中有多个运算模块、多个存储单元时，就要考虑拓扑，让系统整体开销能够被优化。一般的衡量指标有延时、带宽和拥塞程度

### 3.2 内存子系统

寄存器、本地/私有存储、共享存储、全局存储。寄存器内嵌于运算模块，本地/私有存储是某个运算模块独有的存储资源，共享存储时多个运算模块都可访问的存储单元，全局存储是所有模块都可访问的存储资源

一般的优化包括：各个存储模块的参数与内部设计（Pre-silicon），数据到相应存储模块的映射（Memory Mapping）

Pre-silicon:针对简单的数字设计，一般是选择若干已经稳定可靠的RAM IP核，然后套上一层控制逻辑。

Post-silicon:将应用中不同的数据，分配/映射到不同的存储模块，使系统的整体性能提高

## 4 系统参数与设计空间探索

当一个系统的整体功能组件与拓扑确定后，需要解决这些组件，及其互联结构，往往包含大量的待定参数。这些参数及其选择的自由度就形成了设计空间

### 4.1 系统PPA评估模型

为了评估PPA，我们需要进行建模，便于我们对芯片系统的性能做出评估

包括：仿真模型、基于Trace的仿真（记录某些组件在特定应用激励下对外部做出什么事情）、静态分析模型（把所有的组件与互联，变成纯粹的算术函数，根据系统参数与统计数据直接算出PPA）、动态分析模型（将应用的统计参数加入一个小型实时仿真模型中）、基于特征的分析模型（根据应用/架构进行定性分析，对PPA进行定级分析）

### 4.2 设计空间探索算法

模拟退火算法

# Chapter2 验证流程：如何证明“你真行”

## 1 验证的定义与意义

验证是指在流片前，设计人员对每个环节的设计进行的检验，目标是确保当前设计阶段的产出满足设计规范要求。也就是确保我们的设计在特定的输入下能够产生预期的输出

在**系统层面**：验证整体性能和组件之间的通讯与协同；在**组件IP层面**：确定他们的功能是否全部满足预期要求；在**电路层面**：确认每一个电路子啊特定时序要求下产生预期的信号；在**晶体管层面**：确保他们的驱动、负载等特征满足要求

## 2 验证的主要流程

验证的主要流程：确定验证工具、方法、需求、优先级、目标

### 2.1 验证的工具

1. 基于仿真的验证或者基于硬件加速的
2. 基于静态分析--等价性检验、形式化验证等
3. 基于定制工具--例如写好的检验函数和模块，专门针对特定设计规范来检测我们的设计

### 2.2 验证的方法论

1. 如何构建外围的验证框架：可以用UVM所提供的System Verilog库去描述我们的验证用例，检验设计的输入输出
2. 如何引导验证框架生成各种激励：基于一定约束，随机生成一系列输入激励；或者根据自己的理解，人为编写
3. 如何评估设计的输出和内部的运作是否正常：可以利用断言（Assertion），设置标准参考模型

### 2.3 验证的需求

根据设计的功能规范，对设计进行适当的解耦、拆分，自上而下地对各个层面、各个模块明确他们的局部功能、实现细节，明确验证需求

## 3 验证的主要方式与工具

- **静态验证**

1. 代码检测
2. 形式化验证：模块属性检查，模型检查，等价性检查
3. 跨时钟域、跨复位域

- **动态验证**

在软件或者硬件中运行设计的电路来验证设计我们的功能与行为

行为/功能性仿真没有考虑内部逻辑或互联的时序延迟，逻辑综合后仿真或布局后仿真则要考虑延迟的影响

### 3.1 仿真（Simulation）

仿真包括：系统层面的事件驱动仿真（gem5, Multi2Sim, GPGPU-Sim, DRAMSim2），RTL电路波形仿真（Verilator, Synopsys VCS, Mentor Modelsim），在硬件Emulator或者FPGA上的仿真

一般流程：首先根据基于C/C++等高层次语言写好系统/IP级别的事件驱动仿真器，然后完成RTL设计后在波形仿真器上完成信号级别的验证，最后整个大系统结合起来，在FPGA上高速仿真

#### 3.1.1 如何设计外部激励以及如何检验设计的正确性

其实就是写Testbench，testbench的主要功能就是实例化测试对象(Design Under Test, DUT)，生成测试输入向量，比较输出的仿真结果与参考结果

这些测试用例既可以人工设计，也可以利用EDA工具生成，比如Cadence Perspec System Verifier。开源平台UVM提供了更加抽象层次的一些验证

产生激励后观察设计的IO输出是否符合预期，可以在设计中插入**断言**，根据预定条件判断对错的语句

#### 3.1.2 设计内部的信号如何按照设计传递与变化

仿真器一般就是编译器，例如Verilator可以将Verilog按照综合语法、行为规范翻译成C++代码。不同位宽的线与寄存器映射为C++中不同的数据类型与结构，module可以映射为class类，always块、赋值、表达式等可以映射为函数、普通运算表达式。通常的RTL仿真器在原理层面分为两类：

1. 基于事件驱动：对各个模块进行建模，每个模块在特定触发条件下生成事件，这些事件在特定顺序下触发其他模块动作，比如Icarus Verilog
2. 基于时钟驱动：Vrilator，将整个设计扁平化，利用静态分析消除连线并实现功能调度，最终生成C++类

### 3.2 形式化验证（Formal Verification）

#### 3.2.1 形式模型检查

把设计转换为数学表征模型，该模型有特定的状态集合，模型检查工具会遍历这些状态，然后检查一系列形式规范是不是一直被遵守。模型检查主要用于验证设计的Property，这些property主要分为safety properties和liveness properties

1. safety properties: 设计过程中任何时刻都必须满足的属性
2. Liveness properties: 完整的运作中至少在某一时刻满足的属性，即要求某些事情必须发生过，如系统初始化过，访存一定有响应

当我们按照特定规范，加入相关property描述、指定一些信号属性后，这些设计可以导入形式模型检查工具，检验这些属性是否在运行过程中都满足

SAT问题(Boolean Satisfiability Problem): 实际上是一系列布尔表达式，需要求解是否存在对应的布尔变量组合

SMT问题(Satisfiability Modulo Theories): SMT的问题可以包含实数、函数等其他描述 

#### 3.2.2 等价性检查

等价性检查是用形式化数据算法分析两个设计的数据结构，一般用在综合、布局布线这些涉及器件网表被转化的时候

1. 逻辑等价性检验(Logical Equivalence Check, LEC)：Cadence Conformal
   - 映射：在比较网表之前，找到一些关键点进行基本的映射“对齐”。映射的输入包括转换前后的网表以及一些约束或标记，输出则是前后网表的对应关系
   - 比较：使用一个变量序分别建立两个待验证组合逻辑电路的整个BDD二叉决策树，然后比较他们是否同构

## 4 验证的前沿发展

### 4.1 覆盖率的提升

插入断言的覆盖率提升

### 4.2 仿真的加速

1. 通过HLS将高层次系统转为C/C++描述，直接转化为RTL设计，映射到FPGA上
2. 使得UVM实现可综合

### 4.3 针对新兴硬件专用语言的验证框架

Chisel

# Chapter3 基于高层次（HLS）综合的快速生成数字电路设计

## 1 高层次综合的概念与意义

### 1.1 高层次综合的概念

将数字电路设计规范的算法级或行为级描述在一定约束条件下转换为RTL。因为是高层次的描述，可以让工程师专注于算法、架构层面的设计，并且进行快速设计空间的搜索

### 1.2 具体的设计示例

以向量点乘为例

#### 1.2.1 无用户硬件约束的实现

10对4维向量的点乘，C++代码为

```c++
void vectorDot(float A[10][4], float B[10][4],float SUM[10]){
  for(int i=0;i<10;i++){
    SUM[i]=0;
    for(int j=0;j<4;j++){
      SUM[i]+=A[i][j]*B[i][j];
    }
  }
}
```

这个代码就可以直接被HLS编译器转化为RTL电路

#### 1.2.2 简单用户硬件约束的并行加速器实现

考虑并行性的话可以将内层循环展开，这时可以将数据切分使得这些数据可以并行访问。这只需要在C++代码中加入一系列pragma即可

#### 1.2.3 简单用户硬件约束的流水线/并行加速器实现

对于HLS而言，要实现流水线计算也只需要加入一个pragma即可，而如果手改流水线则需要较长时间

总之，HLS的代码量的工作时间比RTL少了90%左右。另外经过pragma的组合，可以针对一个设计探索不同的架构设计的可能

## 2 高层次综合编译器的基本流程与相关功能

目前的HLS编译器是基于LLVM框架的。LLVM会将编译分为3个阶段，前端，中端与后端。

前端主要负责解析源代码以生成IR表示，中端负责IR的Data Flow与Control Flow的优化，后端根据中端的优化后的IR、根据指令集架构生成指令序列（在HLS中生成电路设计）

### 2.1 前端（Front End）

#### 2.1.1 语法树与属性绑定

LLVM的前端主要是Clang，Clang通过对高层次语言的解码、语法分析等步骤，构建出一颗抽象语法树，树里的每一个节点代表一个特定结构。

基于AST可以做一些初步的分析、检验与转化。分析：函数颗粒度，数组最高维数，template信息；检验：源代码能否被合法处理、pragma条件是否能够被满足；转化：Hi-DMM替换一些API函数，Light-HLS给不同区域加上标签

#### 2.1.2 IR的生成

主要基于Clang CodeGen组件将AST转为IR。针对HLS的场景，会存在部分针对FPGA/ASIC特定的IR

IR中的基本块跳转可以抽象为IR的控制流（Control Flow Graph），基本块内部以及基本块之间的数据计算与传递可以抽象为IR的数据流（Data Flow Graph），共同组成CDFG

### 2.2 中端（Mid End）

中端在IR层面对代码进行分析与优化。表达式平衡：让最长的运算链路最短；算子强度弱化（Strength Reduction）：根据数据流特征，将开销较大的运算（整数或浮点整除），转化为开销低的运算（如加减法位运算）；常数传递（Constant Propagation）：直接通过分析，将运行时所作的运算提前到编译时实现；代码提取与吸收（Hosting/Sinking）：根据数据依赖关系，将基本块中的部分运算提取到他们上游或下游基本块执行；函数内联（Inlining）：将函数内部的调用，直接替换为函数代码本身。

这一系列的优化是基于LLVM框架中的Pass完成的，每个Pass相当于一个独立的分析/转化工具

#### 2.2.1 HLS数据流转化/优化

1.  位宽压缩：中间变量的位宽可以被压缩，从而能够节省计算延时/电路面积开销。
2.  冗余（等价）运算消除：完全按照工程师思维展开的代码，其在运行过程中某些地方是会完全等价的，因此需要将其消除
3.  冗余访存消除：多余的内存访问会增加计算延时，也会占用带宽开销
4.  数组切分：有的时候我们希望数据可以被同时访问，从而提高带宽，这个过程就是数组切分

#### 2.2.2 HLS控制流转化/优化

1. 函数实例化（Instantiation）：HLS中的函数一般会被映射为module，通过Interface与外界互动。HLS需要对IR中函数调用进行遍历，对这些调用重新创建相应的、独立的、IR中的函数
2. 循环展开：将不同循环迭代的操作，都生成对应的IR算子，让无依赖的运算可以并行调度和工作

### 2.3 后端（Back End）

后端将IR生成特定的底层代码。对于HLS而言则一般生成Verilog。根据IR所构成的CFG与DFG，可以生成数字电路的状态机（FSM）以及数据通路（Data Path）。

状态机控制数字电路在每一个时钟周期做什么，数据通路根据状态机完成对应的运算

#### 2.3.1 调度（Scheduling）

调度就是根据我们的硬件资源和算子的计算顺序对算子的部署进行合理安排。一个安排的方案就是调度方案

目前已有的调度算法有ASAP（越早越好），ALAP（越晚越好），List（优先级驱动调度），SDC（System of Difference Constraints）

#### 2.3.2 资源绑定（Resource Binding）

就是将调度方案中的算子与具体的硬件资源进行绑定

# Chapter4 标准单元库的设计流程与EDA

## 1 标准单元库（Standard Cell Library）是什么？

standard cell是数字VLSI设计中的基本组件（砖头），比如基本逻辑门（与或非等），Flip-Flop寄存器，MUX多路选择器、加法器等。

标准单元库就是符合某种生产或设计工艺的标准的标准单元，这些信息由芯片制造厂商提供，基于他们提供的Process Design Kit（ PDK）文件，可以在逻辑综合工具与布局布线工具中对PPA指标等进行优化

## 2 为什么针对设计进行Standard Cell Library优化

因为针对不同应用有不同的功耗、面积需求，需要不同的优化

## 3 标准单元库定制的基本流程

### 3.0 主要的优化目标与形式

主要目标：缩小面积、适配驱动能力与负载、实现更低的输入到输出的延时与更低的逻辑功耗

主要形式：**面积方面**：实现Diffusion共享、外部引脚消除；**时序方面**：通过内部信号传递，实现更短的走线；**功耗方面**：减小不必要的驱动要求

### 3.1 确定工艺约束条件

对标准单元进行工艺条件约束后，可以与其他标准单元兼容，且能够交给光刻机生产

#### 3.1.1 cell高度（Height）

高度一般可以用通过多少根横向金属走线进行衡量

#### 3.1.2 cell跨行数（Row）

定制单元是否跨行，跨多少都需要说明。不过针对这种单元的EDA工具链支持得不是很好，主要在学术界有比较多的尝试

#### 3.1.3 cell各层走线限制（密度与方向）

每一个标准单元是由很多半导体工艺层堆叠而来的，每一层有不同的功能

#### 3.1.4 cell输入输出数目（逻辑综合限制）

某个标准单元的定制，一般要设置输入输出的数目限制

### 3.2 确定目标逻辑函数

明确定制逻辑单元的功能如何，主要考虑组合逻辑

#### 3.2.1 什么是对于特定应用、特定约束下，有PPA收益的局部逻辑网表？

1. 出现频率：当一个定制单元能在对应的设计中大量使用时，能够让效果更明显。可以用Frequent Subgraph Mining（FSM）算法找到这些子电路。

2. 时序/面积/功耗的特点：这些特点会被用于定义“有效”的定制

#### 3.2.2 相同逻辑功能的逻辑网表存在多样性

实现相同功能的网表可能有很不一样的PPA指标。

### 3.3 确定SPICE网表

在晶体管层面进行设计

可以基于逻辑表达式构建CMOS网络。主要的优化PPA的方法有：增大晶体管尺寸，逐级加大尺寸，重新安排输入，重组逻辑结构等。

最终晶体管的尺寸、连接关系，可以在SPICE文件中进行描述

### 3.4 版图生成

VLSI电路是经过多道工艺流程、在不同层面堆叠进行实现的。不同的工艺层包含不同的功能

#### 3.4.1 设计规则

#### 3.4.2 可布线性

版图生成的常用算法是模拟退火、MILP、SMT、机器学习等

### 3.5 参数提取与Liberty文件生成

为了能够将定制单元整合入上下游的逻辑综合、布局布线EDA工具，需要有Liberty文件。这个文件中记录啦每个标准单元的功能、面积、电容参数、引脚、各种情况下的延时与功耗等

## 4 自动化搜索与迭代

自动生成可供参考的定制标准单元，可以显著提高设计效率

# Chapter5 布局算法怎么实现芯片的“核舟记”？

## 1 布局的概述

### 1.1 布局的基本定义

主要就是将逻辑综合生成的门级网表，排布到一个矩形区域内。这样一个布局要确保后续的布线、工艺检查等步骤的可行性。布局有一系列的评价指标，如面积（Area），走线长度（Wirelength），关键路径延时长度（Critical Path Delay，CPD），功耗（Power）等。

ASIC的设计方法有基于Standard Cell的定制和完全定制（Full Custom）。

FPGA是一种可编程的ASIC可以在制造后重新配置。与ASIC相比，FPGA主要增加了电路布局的离散性限制，每个器件必须映射到FPGA已有的组件上。FPGA布局的芯片上各类资源的分布是不均匀的。FPGA上合法化（legalization）是指把电路设计中的实例映射到FPGA的组件上

### 1.2 布局基本流程

#### 1.2.1 时序分析与线长评估（Timing Analysis/Wirelength Evaluation）

布线之前，要在布局阶段评估布线时走线长度与质量或时序质量。

#### 1.2.2 初始版图大致规划（Floorplanning/Chip Planning）

将整个电路划分为几个大块（Partitioning），决定这几个大块之间的相对位置。

#### 1.2.3 时序/线长驱动的全局布局

每个实例的位置通过解决线长和时序相关的优化问题来决定（模拟退火，图切割等）。

#### 1.2.4 器件扩散

根据实例的面积需求和实际版图上某个区域的面积供应，实例会从资源供不应求的区域向其他区域扩散

#### 1.2.5 器件面积修正

根据打包可行性和布线拥塞程度，一些标准单元的面积需求会缩小或增加，一些区域的面积供应会增加或减小

#### 1.2.6 合法化与打包

每个实例要与其它实例打包到一起，根据某些指标映射到一个确切位置，让某些指标最优化

#### 1.2.7 细致布局

基于全局布局，微调各个器件的位置，对目标函数进行进一步的优化

## 2 布局的各个主要环节相关功能

### 2.1 线长与时序评估

线长与时序是布局问题中最重要的两个问题。线长作为时序的一种近似。线长越短，时序越好

#### 2.1.1 线长模型

1. 布局中，我们会用一些布线模式去近似实际布线器的走线。半周线长（half-perimeter wirelength，HPWL）是最常用的布线模式

2. 把线长“数值函数化”，从而方便我们的数学建模。可以直接用类似遗传算法或者模拟退火算法的布局算法进行函数求解

#### 2.1.2 时序评估

时序分析需要确保，每个被时钟触发的信号，都能从其引脚除法、在下一个时钟触发前、经过一系列逻辑电路和走线抵达目标引脚。

首先要创建时序图（Timing Graph），其中每个电路的实例构成图中的节点（Timing node），创建时序边（Timing edge）连接每一个发出信号的引脚以及接受信号的引脚。从而将电路转化为有向无环图（Directed Acyclic Graph，DAG）

### 2.2 初始版图大致计划

#### 2.2.1 网表切分（Netlist Partitioning）

1. 最小化切分后的子图、团之间的连接数
2. 每个子图的面积/资源需求小于某个设计约束
3. 尽可能平衡每个子图的资源或面积大小

#### 2.2.2 电路块布局（Cluster Placement）

切分后就可以决定这些Cluster的位置，经典算法是Slicing tree算法，还有模拟退火算法

### 2.3 时序/线长驱动的全局布局

全局布局通常启动一个迭代优化的过程，目前较新的是基于解析模型进行数值求解

#### 2.3.1 布局问题的数学解析模型

优化布局问题是希望最小化线长或者优化时序，可以利用Bound2Bound近似将HPWL近似为二次函数，再利用DREAMPlacer将器件摊开

#### 2.3.2 布局问题数值求解

得到解析数学模型后就可以放进数学求解器进行求解了

### 2.4 器件扩散

要把实例合理得散开，从资源不足的地方散到资源充足的地方。

### 2.5 器件面积修正

#### 2.5.1 兼容性面积修正

有些实例要打包在一起的前提是必须共享某些信号，所以相当于不互相兼容的实例，他们所需的面积/资源变大了

#### 2.5.2 拥塞面积修正