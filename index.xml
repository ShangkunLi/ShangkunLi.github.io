<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shangkun&#39;s Blog</title>
    <link>https://shangkunli.github.io/</link>
    <description>Recent content on Shangkun&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 29 Apr 2023 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://shangkunli.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>EDA流程与概述</title>
      <link>https://shangkunli.github.io/post/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023-2-6-eda%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Sat, 29 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2023-2-6-eda%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%A6%82%E8%BF%B0/</guid>
      
        <description>&lt;h1 id=&#34;eda流程与概述&#34;&gt;EDA流程与概述&lt;/h1&gt;
&lt;p&gt;这一系列笔记主要是我学习知乎答主格律的文章的记录&lt;/p&gt;
&lt;p&gt;强烈推荐阅读他的文章，我的记录只是根据我自己的理解写下的，方便我日后回顾&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/380962676&#34;&gt;设计VLSI EDA&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;chapter0-eda的what-why-how&#34;&gt;Chapter0 EDA的What, Why, How&lt;/h1&gt;
&lt;h2 id=&#34;1-whatvlsi-eda是什么&#34;&gt;1 What：VLSI EDA是什么&lt;/h2&gt;
&lt;p&gt;将非常复杂的电子电路塞到一块很小的芯片上，直接靠人力显然是很难实现的。因此我们使用计算机辅助设计(Compuer -Aided Design, CAD)进行电路设计。然后通过计算机算法，把在软件上设计好的电路映射到芯片上，就得到了我们想要的芯片。&lt;/p&gt;
&lt;h2 id=&#34;2-whyhow为什么要用eda及其内部的原理&#34;&gt;2 Why&amp;amp;How：为什么要用EDA，及其内部的原理&lt;/h2&gt;
&lt;h3 id=&#34;21-设计芯片规格&#34;&gt;2.1 设计芯片规格&lt;/h3&gt;
&lt;p&gt;这主要是上层的设计，还不涉及到coding的环节。需要设计出CPU的框架、功能、模块划分等等，包括以下几个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指令集架构：比如x86、ARM、RISC-V架构。比如一些EDA软件（Cadence的Tensilica SDK、Synopsis CEVA）支持自定义新的指令，并把这些定制指令整合到已有CPU处理器中&lt;/li&gt;
&lt;li&gt;微系统架构：主要是硬件架构方面，如芯片的内部系列组件（GIB、IOB、PE等等）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;做好了这些设计，需要进行系统级（system level）的仿真，或者行为级（behavioral）的仿真。以此来验证这个上层设计合不合理，性能、功耗、面积（PPA指标，Power-Performance-Area）如何。常用的系统级仿真器有gem5&lt;/p&gt;
&lt;h3 id=&#34;22-硬件设计描述&#34;&gt;2.2 硬件设计描述&lt;/h3&gt;
&lt;p&gt;在上层设计及仿真都没啥问题之后，我们就可以开始coding了，这一部分就主要是通过写HDL代码来进行具体的设计。&lt;/p&gt;
&lt;p&gt;在这一个环节中，EDA工具作用体现在两个方面&lt;/p&gt;
&lt;h4 id=&#34;221-设计库的高效灵活重用&#34;&gt;2.2.1 设计库的高效、灵活重用&lt;/h4&gt;
&lt;p&gt;比如这段时间RISC-V的提出，重新吸引力人们对于架构的关心。在进行RISC-V架构设计的过程中，提出了Chisel语言。Chisel可以让我们在更高、更抽象的层面进行设计，然后利用chisel的框架参数化地生成verilog代码，大大减少了在底层代码上花费的时间。&lt;/p&gt;
&lt;h4 id=&#34;222-高层次综合&#34;&gt;2.2.2 高层次综合&lt;/h4&gt;
&lt;p&gt;这就是利用C++、Python这些语言进行硬件设计，利用编译器将这些代码转换为低层次的语言，比如Verilog/VHDL等。算法其实就是Control Flow+Data Flow，所以可以按照某些规则将Control Flow转换成有限状态机，将Data Flow转换成由寄存器与运算逻辑构成的数据通路。&lt;/p&gt;
&lt;p&gt;目前商用的HLS工具有Xilinx Vitis HLS、Intel HLS，学术界开源的有LegUp、BamBu、GAUT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HLS流程概述&lt;/strong&gt;：一共分为前端、中端与后端。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前端：解析高层次语言，生成AST，再转换成IR&lt;/li&gt;
&lt;li&gt;中端：对IR、DFG进行优化&lt;/li&gt;
&lt;li&gt;后端：将优化好的DFG转换为FSM+Datapath，即把&lt;strong&gt;调度&lt;/strong&gt;（把各个操作映射到不同的时钟周期内，实现不同颗粒度的流水线）与&lt;strong&gt;资源绑定&lt;/strong&gt;（把各个操作映射到运算资源上面）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-针对功能验证的设计&#34;&gt;2.3 针对功能验证的设计&lt;/h3&gt;
&lt;p&gt;在完成HDL的书写之后，需要对其进行功能性的进行验证，以验证我们的HDL写得没有问题，能够完成我们的目标工作&lt;/p&gt;
&lt;p&gt;主要就是行为级验证（Functional Verification）&lt;/p&gt;
&lt;h4 id=&#34;231-基于仿真的验证&#34;&gt;2.3.1 基于仿真的验证&lt;/h4&gt;
&lt;h5 id=&#34;2311-给设计的外部信号咋来的&#34;&gt;2.3.1.1 给设计的外部信号咋来的？&lt;/h5&gt;
&lt;p&gt;这一外部信号主要是由验证平台产生的，比如UVM(Universal Verification Methodology)。提高了验证的抽象层次，把验证功能模块化，把过程变成一个个事务（Transaction）。&lt;/p&gt;
&lt;h5 id=&#34;2312-设计内部信号如何按照设计进行传递与变化&#34;&gt;2.3.1.2 设计内部信号如何按照设计进行传递与变化&lt;/h5&gt;
&lt;p&gt;仿真器一般会将Verilog等RTL描述根据综合语法、行为规范翻译成C++代码。&lt;/p&gt;
&lt;p&gt;比如不同的wire与reg对应C++中不同的数据类型与结构，module对应class。always块、表达式等可以映射为函数、运算表达式等。总之就可以理解为在针对功能的仿真中是将Verilog映射到C++中，用C++模拟出各种逻辑功能的实现。&lt;/p&gt;
&lt;h4 id=&#34;232-形式化验证&#34;&gt;2.3.2 形式化验证&lt;/h4&gt;
&lt;p&gt;形式化验证大致分为形式模型检查（Formal Model Checking），等价性检查（Equivalence Checking），定理证明（Theory Proving)。主要是从**“理论上”**证明设计的功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;形式模型检查：将设计转换为数学表征的模型，然后利用模型检查工具遍历模型的状态集合，检查定义的形式规范是否一直被遵守&lt;/li&gt;
&lt;li&gt;等价性检查：一般用在综合、布局布线这些设计器件网表会被转化改变的时候。通过建立起两个待验证电路的BDD二叉决策树，利用一些算法比较他们是否相同&lt;/li&gt;
&lt;li&gt;定理证明：待补&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;24-逻辑综合&#34;&gt;2.4 逻辑综合&lt;/h3&gt;
&lt;p&gt;将RTL级描述转化为门级表达的过程，叫做逻辑综合。这一过程的一般目标是减少面积资源的需求、提高设计频率、降低功耗&lt;/p&gt;
&lt;h4 id=&#34;241-组合逻辑优化&#34;&gt;2.4.1 组合逻辑优化&lt;/h4&gt;
&lt;p&gt;也就是布尔逻辑式的最小化，找到最简单门级电路实现的布尔表达式。比如利用卡诺图化简等等&lt;/p&gt;
&lt;h4 id=&#34;242-时序逻辑优化&#34;&gt;2.4.2 时序逻辑优化&lt;/h4&gt;
&lt;p&gt;时序电路有最高频率的限制，通过Retiming算法可以移动寄存器在DAG（有向无环图）网表中的位置，从而有可能实现更高频的数字电路&lt;/p&gt;
&lt;h4 id=&#34;243-工艺映射&#34;&gt;2.4.3 工艺映射&lt;/h4&gt;
&lt;p&gt;将RTL生成的逻辑行为网表与standard cell库中的元件进行组合、布局、连接，从而映射成一个个逻辑器件，最终变成门级网表。&lt;/p&gt;
&lt;h3 id=&#34;25-物理综合&#34;&gt;2.5 物理综合&lt;/h3&gt;
&lt;p&gt;当有了门级网表之后，就需要把这些器件放在给定的芯片上了。这一部分就需要考虑更加细致的器件、工艺等实际因素了，这就是物理综合。&lt;/p&gt;
&lt;h4 id=&#34;251-布局&#34;&gt;2.5.1 布局&lt;/h4&gt;
&lt;p&gt;布局就是将逻辑综合生成的门级网表合理地排布在一个矩阵区域内。既要保证后续布线、工艺检查的可行性，又要考虑一系列评价指标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局布局：决定各器件在芯片上大致的位置，一般是以模块进行划分&lt;/li&gt;
&lt;li&gt;细致布局：不断进行迭代，逐渐进行优化（可以用模拟退火算法，分割网表的方法，解析法等）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;252-布线&#34;&gt;2.5.2 布线&lt;/h4&gt;
&lt;p&gt;将放置在板子上的芯片用线连接起来&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局布线：将芯片划分为几个不同的区域，然后在不同区域之间连线&lt;/li&gt;
&lt;li&gt;细致布线：在全局布线的基础上，连接器件&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;chapter1-辅助架构设计与仿真中的eda原理&#34;&gt;Chapter1 辅助架构设计与仿真中的EDA原理&lt;/h1&gt;
&lt;h2 id=&#34;1-架构的定义&#34;&gt;1 架构的定义&lt;/h2&gt;
&lt;p&gt;这里的架构主要指的是SoC架构。这里面包括芯片系统中包含什么组件、组件之间怎么连接、如何进行交互这3个问题。&lt;/p&gt;
&lt;p&gt;设计中需要考虑很多因素，这些因素会影响最终的收益与成本。因此目前架构设计中的难点主要有映射、评估分析以及高效自动化的设计空间探索。&lt;/p&gt;
&lt;h2 id=&#34;2-系统功能组件&#34;&gt;2 系统功能、组件&lt;/h2&gt;
&lt;p&gt;首先根据需求和应用确定芯片的具体功能，这些功能将会决定大致需要哪些组件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先构思解决问题在软件层面的算法，如神经网络、机器学习、加密解密等&lt;/li&gt;
&lt;li&gt;然后对这些算法的控制流及数据流进行特征分析，如控制的模式、数据的颗粒度&lt;/li&gt;
&lt;li&gt;并非所有功能都要在硬件上实现，要对应用进行软硬协同设计，考虑哪些部分可以下放到硬件上处理，哪些保留在软件层面实现&lt;/li&gt;
&lt;li&gt;针对输入输出、硬件上的处理流程，对芯片进行模块化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;21-应用特征分析&#34;&gt;2.1 应用特征分析&lt;/h3&gt;
&lt;p&gt;VLSI设计分为三类：计算密集型（算法中有大量的运算，需要经过较多处理后才会输出），数据密集型（数据处理链路很短/快，但是数据吞吐量&amp;gt;数据读写量，瓶颈在于数据读写带宽或数据利用率），控制密集型（计算量不多，但是有很多条件分支）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;EDA静态分析：&lt;/p&gt;
&lt;p&gt;利用高性能应用编译器（CUDA，HLS编译器）的内置功能，把代码转为IR，对应用的控制流、数据流进行分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EDA动态分析：&lt;/p&gt;
&lt;p&gt;通过一些测试输入，模拟/检测算法的运行过程&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-应用软硬件协同设计&#34;&gt;2.2 应用软硬件协同设计&lt;/h3&gt;
&lt;p&gt;软硬协同设计的第一部分是软硬件划分。本质上是将应用划分为通用处理器负责的部分与设计者定制的部分&lt;/p&gt;
&lt;p&gt;软硬件划分可以分为细粒度（指令集）划分和粗颗粒度（函数、代码块）划分。&lt;/p&gt;
&lt;p&gt;细粒度划分：可以分析源码发现其中的性能瓶颈语句，然后定制出指令替换掉源码，并将定制指令运行在协处理器（Co-Processor）中&lt;/p&gt;
&lt;p&gt;粗粒度划分：展示各函数的调用频率，比较二者（在CPU与FPGA）实现效率，从而让设计者选定需要在FPGA上加速的函数&lt;/p&gt;
&lt;h3 id=&#34;23-组件的选用与组件的通用专用与定制&#34;&gt;2.3 组件的选用与组件的通用、专用与定制&lt;/h3&gt;
&lt;p&gt;可以利用2.2中的EDA工具直接生成硬件模块。但一般为了追求更高性能，一般会人工设计。这一过程需要选用组件。部分组件是现成的，有的需要定制，这就是IP&lt;/p&gt;
&lt;p&gt;组件类型的选取：一些组件要完成的功能较复杂多变，选用通用设计，如MCU；一些有特定功能，选专用设计；如果没有现成设计，需要定制&lt;/p&gt;
&lt;p&gt;EDA工具可以协助设计者分析PPA，然后不断变换组件组合和参数，实现最优化，也就是设计空间探索&lt;/p&gt;
&lt;h2 id=&#34;3-系统层次拓扑与互动关联&#34;&gt;3 系统层次、拓扑与互动关联&lt;/h2&gt;
&lt;p&gt;层次是指模块与模块之间的包含关系；拓扑是针对同一层次中，各组件的连接关系；互动石河子组件之间的通讯形式与内容&lt;/p&gt;
&lt;h3 id=&#34;31-运算存储与通讯&#34;&gt;3.1 运算、存储与通讯&lt;/h3&gt;
&lt;p&gt;由于系统中存储与运算模块一般是分离的，他们之间存在通讯，所以我们一般希望存储单元离运算单元越近越好。因此出现了多级缓存的设计，以及存内计算的设计&lt;/p&gt;
&lt;p&gt;当系统中有多个运算模块、多个存储单元时，就要考虑拓扑，让系统整体开销能够被优化。一般的衡量指标有延时、带宽和拥塞程度&lt;/p&gt;
&lt;h3 id=&#34;32-内存子系统&#34;&gt;3.2 内存子系统&lt;/h3&gt;
&lt;p&gt;寄存器、本地/私有存储、共享存储、全局存储。寄存器内嵌于运算模块，本地/私有存储是某个运算模块独有的存储资源，共享存储时多个运算模块都可访问的存储单元，全局存储是所有模块都可访问的存储资源&lt;/p&gt;
&lt;p&gt;一般的优化包括：各个存储模块的参数与内部设计（Pre-silicon），数据到相应存储模块的映射（Memory Mapping）&lt;/p&gt;
&lt;p&gt;Pre-silicon:针对简单的数字设计，一般是选择若干已经稳定可靠的RAM IP核，然后套上一层控制逻辑。&lt;/p&gt;
&lt;p&gt;Post-silicon:将应用中不同的数据，分配/映射到不同的存储模块，使系统的整体性能提高&lt;/p&gt;
&lt;h2 id=&#34;4-系统参数与设计空间探索&#34;&gt;4 系统参数与设计空间探索&lt;/h2&gt;
&lt;p&gt;当一个系统的整体功能组件与拓扑确定后，需要解决这些组件，及其互联结构，往往包含大量的待定参数。这些参数及其选择的自由度就形成了设计空间&lt;/p&gt;
&lt;h3 id=&#34;41-系统ppa评估模型&#34;&gt;4.1 系统PPA评估模型&lt;/h3&gt;
&lt;p&gt;为了评估PPA，我们需要进行建模，便于我们对芯片系统的性能做出评估&lt;/p&gt;
&lt;p&gt;包括：仿真模型、基于Trace的仿真（记录某些组件在特定应用激励下对外部做出什么事情）、静态分析模型（把所有的组件与互联，变成纯粹的算术函数，根据系统参数与统计数据直接算出PPA）、动态分析模型（将应用的统计参数加入一个小型实时仿真模型中）、基于特征的分析模型（根据应用/架构进行定性分析，对PPA进行定级分析）&lt;/p&gt;
&lt;h3 id=&#34;42-设计空间探索算法&#34;&gt;4.2 设计空间探索算法&lt;/h3&gt;
&lt;p&gt;模拟退火算法&lt;/p&gt;
&lt;h1 id=&#34;chapter2-验证流程如何证明你真行&#34;&gt;Chapter2 验证流程：如何证明“你真行”&lt;/h1&gt;
&lt;h2 id=&#34;1-验证的定义与意义&#34;&gt;1 验证的定义与意义&lt;/h2&gt;
&lt;p&gt;验证是指在流片前，设计人员对每个环节的设计进行的检验，目标是确保当前设计阶段的产出满足设计规范要求。也就是确保我们的设计在特定的输入下能够产生预期的输出&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;系统层面&lt;/strong&gt;：验证整体性能和组件之间的通讯与协同；在&lt;strong&gt;组件IP层面&lt;/strong&gt;：确定他们的功能是否全部满足预期要求；在&lt;strong&gt;电路层面&lt;/strong&gt;：确认每一个电路子啊特定时序要求下产生预期的信号；在&lt;strong&gt;晶体管层面&lt;/strong&gt;：确保他们的驱动、负载等特征满足要求&lt;/p&gt;
&lt;h2 id=&#34;2-验证的主要流程&#34;&gt;2 验证的主要流程&lt;/h2&gt;
&lt;p&gt;验证的主要流程：确定验证工具、方法、需求、优先级、目标&lt;/p&gt;
&lt;h3 id=&#34;21-验证的工具&#34;&gt;2.1 验证的工具&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;基于仿真的验证或者基于硬件加速的&lt;/li&gt;
&lt;li&gt;基于静态分析&amp;ndash;等价性检验、形式化验证等&lt;/li&gt;
&lt;li&gt;基于定制工具&amp;ndash;例如写好的检验函数和模块，专门针对特定设计规范来检测我们的设计&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-验证的方法论&#34;&gt;2.2 验证的方法论&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如何构建外围的验证框架：可以用UVM所提供的System Verilog库去描述我们的验证用例，检验设计的输入输出&lt;/li&gt;
&lt;li&gt;如何引导验证框架生成各种激励：基于一定约束，随机生成一系列输入激励；或者根据自己的理解，人为编写&lt;/li&gt;
&lt;li&gt;如何评估设计的输出和内部的运作是否正常：可以利用断言（Assertion），设置标准参考模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-验证的需求&#34;&gt;2.3 验证的需求&lt;/h3&gt;
&lt;p&gt;根据设计的功能规范，对设计进行适当的解耦、拆分，自上而下地对各个层面、各个模块明确他们的局部功能、实现细节，明确验证需求&lt;/p&gt;
&lt;h2 id=&#34;3-验证的主要方式与工具&#34;&gt;3 验证的主要方式与工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态验证&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;代码检测&lt;/li&gt;
&lt;li&gt;形式化验证：模块属性检查，模型检查，等价性检查&lt;/li&gt;
&lt;li&gt;跨时钟域、跨复位域&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态验证&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在软件或者硬件中运行设计的电路来验证设计我们的功能与行为&lt;/p&gt;
&lt;p&gt;行为/功能性仿真没有考虑内部逻辑或互联的时序延迟，逻辑综合后仿真或布局后仿真则要考虑延迟的影响&lt;/p&gt;
&lt;h3 id=&#34;31-仿真simulation&#34;&gt;3.1 仿真（Simulation）&lt;/h3&gt;
&lt;p&gt;仿真包括：系统层面的事件驱动仿真（gem5, Multi2Sim, GPGPU-Sim, DRAMSim2），RTL电路波形仿真（Verilator, Synopsys VCS, Mentor Modelsim），在硬件Emulator或者FPGA上的仿真&lt;/p&gt;
&lt;p&gt;一般流程：首先根据基于C/C++等高层次语言写好系统/IP级别的事件驱动仿真器，然后完成RTL设计后在波形仿真器上完成信号级别的验证，最后整个大系统结合起来，在FPGA上高速仿真&lt;/p&gt;
&lt;h4 id=&#34;311-如何设计外部激励以及如何检验设计的正确性&#34;&gt;3.1.1 如何设计外部激励以及如何检验设计的正确性&lt;/h4&gt;
&lt;p&gt;其实就是写Testbench，testbench的主要功能就是实例化测试对象(Design Under Test, DUT)，生成测试输入向量，比较输出的仿真结果与参考结果&lt;/p&gt;
&lt;p&gt;这些测试用例既可以人工设计，也可以利用EDA工具生成，比如Cadence Perspec System Verifier。开源平台UVM提供了更加抽象层次的一些验证&lt;/p&gt;
&lt;p&gt;产生激励后观察设计的IO输出是否符合预期，可以在设计中插入&lt;strong&gt;断言&lt;/strong&gt;，根据预定条件判断对错的语句&lt;/p&gt;
&lt;h4 id=&#34;312-设计内部的信号如何按照设计传递与变化&#34;&gt;3.1.2 设计内部的信号如何按照设计传递与变化&lt;/h4&gt;
&lt;p&gt;仿真器一般就是编译器，例如Verilator可以将Verilog按照综合语法、行为规范翻译成C++代码。不同位宽的线与寄存器映射为C++中不同的数据类型与结构，module可以映射为class类，always块、赋值、表达式等可以映射为函数、普通运算表达式。通常的RTL仿真器在原理层面分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于事件驱动：对各个模块进行建模，每个模块在特定触发条件下生成事件，这些事件在特定顺序下触发其他模块动作，比如Icarus Verilog&lt;/li&gt;
&lt;li&gt;基于时钟驱动：Vrilator，将整个设计扁平化，利用静态分析消除连线并实现功能调度，最终生成C++类&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-形式化验证formal-verification&#34;&gt;3.2 形式化验证（Formal Verification）&lt;/h3&gt;
&lt;h4 id=&#34;321-形式模型检查&#34;&gt;3.2.1 形式模型检查&lt;/h4&gt;
&lt;p&gt;把设计转换为数学表征模型，该模型有特定的状态集合，模型检查工具会遍历这些状态，然后检查一系列形式规范是不是一直被遵守。模型检查主要用于验证设计的Property，这些property主要分为safety properties和liveness properties&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;safety properties: 设计过程中任何时刻都必须满足的属性&lt;/li&gt;
&lt;li&gt;Liveness properties: 完整的运作中至少在某一时刻满足的属性，即要求某些事情必须发生过，如系统初始化过，访存一定有响应&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当我们按照特定规范，加入相关property描述、指定一些信号属性后，这些设计可以导入形式模型检查工具，检验这些属性是否在运行过程中都满足&lt;/p&gt;
&lt;p&gt;SAT问题(Boolean Satisfiability Problem): 实际上是一系列布尔表达式，需要求解是否存在对应的布尔变量组合&lt;/p&gt;
&lt;p&gt;SMT问题(Satisfiability Modulo Theories): SMT的问题可以包含实数、函数等其他描述&lt;/p&gt;
&lt;h4 id=&#34;322-等价性检查&#34;&gt;3.2.2 等价性检查&lt;/h4&gt;
&lt;p&gt;等价性检查是用形式化数据算法分析两个设计的数据结构，一般用在综合、布局布线这些涉及器件网表被转化的时候&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑等价性检验(Logical Equivalence Check, LEC)：Cadence Conformal
&lt;ul&gt;
&lt;li&gt;映射：在比较网表之前，找到一些关键点进行基本的映射“对齐”。映射的输入包括转换前后的网表以及一些约束或标记，输出则是前后网表的对应关系&lt;/li&gt;
&lt;li&gt;比较：使用一个变量序分别建立两个待验证组合逻辑电路的整个BDD二叉决策树，然后比较他们是否同构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-验证的前沿发展&#34;&gt;4 验证的前沿发展&lt;/h2&gt;
&lt;h3 id=&#34;41-覆盖率的提升&#34;&gt;4.1 覆盖率的提升&lt;/h3&gt;
&lt;p&gt;插入断言的覆盖率提升&lt;/p&gt;
&lt;h3 id=&#34;42-仿真的加速&#34;&gt;4.2 仿真的加速&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过HLS将高层次系统转为C/C++描述，直接转化为RTL设计，映射到FPGA上&lt;/li&gt;
&lt;li&gt;使得UVM实现可综合&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-针对新兴硬件专用语言的验证框架&#34;&gt;4.3 针对新兴硬件专用语言的验证框架&lt;/h3&gt;
&lt;p&gt;Chisel&lt;/p&gt;
&lt;h1 id=&#34;chapter3-基于高层次hls综合的快速生成数字电路设计&#34;&gt;Chapter3 基于高层次（HLS）综合的快速生成数字电路设计&lt;/h1&gt;
&lt;h2 id=&#34;1-高层次综合的概念与意义&#34;&gt;1 高层次综合的概念与意义&lt;/h2&gt;
&lt;h3 id=&#34;11-高层次综合的概念&#34;&gt;1.1 高层次综合的概念&lt;/h3&gt;
&lt;p&gt;将数字电路设计规范的算法级或行为级描述在一定约束条件下转换为RTL。因为是高层次的描述，可以让工程师专注于算法、架构层面的设计，并且进行快速设计空间的搜索&lt;/p&gt;
&lt;h3 id=&#34;12-具体的设计示例&#34;&gt;1.2 具体的设计示例&lt;/h3&gt;
&lt;p&gt;以向量点乘为例&lt;/p&gt;
&lt;h4 id=&#34;121-无用户硬件约束的实现&#34;&gt;1.2.1 无用户硬件约束的实现&lt;/h4&gt;
&lt;p&gt;10对4维向量的点乘，C++代码为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-1&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-1&#34;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-2&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-2&#34;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-3&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-3&#34;&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-4&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-4&#34;&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-5&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-5&#34;&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-6&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-6&#34;&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-7&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-7&#34;&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-8&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-8&#34;&gt;8&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#902000&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#06287e&#34;&gt;vectorDot&lt;/span&gt;(&lt;span style=&#34;color:#902000&#34;&gt;float&lt;/span&gt; A[&lt;span style=&#34;color:#40a070&#34;&gt;10&lt;/span&gt;][&lt;span style=&#34;color:#40a070&#34;&gt;4&lt;/span&gt;], &lt;span style=&#34;color:#902000&#34;&gt;float&lt;/span&gt; B[&lt;span style=&#34;color:#40a070&#34;&gt;10&lt;/span&gt;][&lt;span style=&#34;color:#40a070&#34;&gt;4&lt;/span&gt;],&lt;span style=&#34;color:#902000&#34;&gt;float&lt;/span&gt; SUM[&lt;span style=&#34;color:#40a070&#34;&gt;10&lt;/span&gt;]){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#902000&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;10&lt;/span&gt;;i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    SUM[i]&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#902000&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;0&lt;/span&gt;;j&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;4&lt;/span&gt;;j&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      SUM[i]&lt;span style=&#34;color:#666&#34;&gt;+=&lt;/span&gt;A[i][j]&lt;span style=&#34;color:#666&#34;&gt;*&lt;/span&gt;B[i][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个代码就可以直接被HLS编译器转化为RTL电路&lt;/p&gt;
&lt;h4 id=&#34;122-简单用户硬件约束的并行加速器实现&#34;&gt;1.2.2 简单用户硬件约束的并行加速器实现&lt;/h4&gt;
&lt;p&gt;考虑并行性的话可以将内层循环展开，这时可以将数据切分使得这些数据可以并行访问。这只需要在C++代码中加入一系列pragma即可&lt;/p&gt;
&lt;h4 id=&#34;123-简单用户硬件约束的流水线并行加速器实现&#34;&gt;1.2.3 简单用户硬件约束的流水线/并行加速器实现&lt;/h4&gt;
&lt;p&gt;对于HLS而言，要实现流水线计算也只需要加入一个pragma即可，而如果手改流水线则需要较长时间&lt;/p&gt;
&lt;p&gt;总之，HLS的代码量的工作时间比RTL少了90%左右。另外经过pragma的组合，可以针对一个设计探索不同的架构设计的可能&lt;/p&gt;
&lt;h2 id=&#34;2-高层次综合编译器的基本流程与相关功能&#34;&gt;2 高层次综合编译器的基本流程与相关功能&lt;/h2&gt;
&lt;p&gt;目前的HLS编译器是基于LLVM框架的。LLVM会将编译分为3个阶段，前端，中端与后端。&lt;/p&gt;
&lt;p&gt;前端主要负责解析源代码以生成IR表示，中端负责IR的Data Flow与Control Flow的优化，后端根据中端的优化后的IR、根据指令集架构生成指令序列（在HLS中生成电路设计）&lt;/p&gt;
&lt;h3 id=&#34;21-前端front-end&#34;&gt;2.1 前端（Front End）&lt;/h3&gt;
&lt;h4 id=&#34;211-语法树与属性绑定&#34;&gt;2.1.1 语法树与属性绑定&lt;/h4&gt;
&lt;p&gt;LLVM的前端主要是Clang，Clang通过对高层次语言的解码、语法分析等步骤，构建出一颗抽象语法树，树里的每一个节点代表一个特定结构。&lt;/p&gt;
&lt;p&gt;基于AST可以做一些初步的分析、检验与转化。分析：函数颗粒度，数组最高维数，template信息；检验：源代码能否被合法处理、pragma条件是否能够被满足；转化：Hi-DMM替换一些API函数，Light-HLS给不同区域加上标签&lt;/p&gt;
&lt;h4 id=&#34;212-ir的生成&#34;&gt;2.1.2 IR的生成&lt;/h4&gt;
&lt;p&gt;主要基于Clang CodeGen组件将AST转为IR。针对HLS的场景，会存在部分针对FPGA/ASIC特定的IR&lt;/p&gt;
&lt;p&gt;IR中的基本块跳转可以抽象为IR的控制流（Control Flow Graph），基本块内部以及基本块之间的数据计算与传递可以抽象为IR的数据流（Data Flow Graph），共同组成CDFG&lt;/p&gt;
&lt;h3 id=&#34;22-中端mid-end&#34;&gt;2.2 中端（Mid End）&lt;/h3&gt;
&lt;p&gt;中端在IR层面对代码进行分析与优化。表达式平衡：让最长的运算链路最短；算子强度弱化（Strength Reduction）：根据数据流特征，将开销较大的运算（整数或浮点整除），转化为开销低的运算（如加减法位运算）；常数传递（Constant Propagation）：直接通过分析，将运行时所作的运算提前到编译时实现；代码提取与吸收（Hosting/Sinking）：根据数据依赖关系，将基本块中的部分运算提取到他们上游或下游基本块执行；函数内联（Inlining）：将函数内部的调用，直接替换为函数代码本身。&lt;/p&gt;
&lt;p&gt;这一系列的优化是基于LLVM框架中的Pass完成的，每个Pass相当于一个独立的分析/转化工具&lt;/p&gt;
&lt;h4 id=&#34;221-hls数据流转化优化&#34;&gt;2.2.1 HLS数据流转化/优化&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;位宽压缩：中间变量的位宽可以被压缩，从而能够节省计算延时/电路面积开销。&lt;/li&gt;
&lt;li&gt;冗余（等价）运算消除：完全按照工程师思维展开的代码，其在运行过程中某些地方是会完全等价的，因此需要将其消除&lt;/li&gt;
&lt;li&gt;冗余访存消除：多余的内存访问会增加计算延时，也会占用带宽开销&lt;/li&gt;
&lt;li&gt;数组切分：有的时候我们希望数据可以被同时访问，从而提高带宽，这个过程就是数组切分&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;222-hls控制流转化优化&#34;&gt;2.2.2 HLS控制流转化/优化&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;函数实例化（Instantiation）：HLS中的函数一般会被映射为module，通过Interface与外界互动。HLS需要对IR中函数调用进行遍历，对这些调用重新创建相应的、独立的、IR中的函数&lt;/li&gt;
&lt;li&gt;循环展开：将不同循环迭代的操作，都生成对应的IR算子，让无依赖的运算可以并行调度和工作&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-后端back-end&#34;&gt;2.3 后端（Back End）&lt;/h3&gt;
&lt;p&gt;后端将IR生成特定的底层代码。对于HLS而言则一般生成Verilog。根据IR所构成的CFG与DFG，可以生成数字电路的状态机（FSM）以及数据通路（Data Path）。&lt;/p&gt;
&lt;p&gt;状态机控制数字电路在每一个时钟周期做什么，数据通路根据状态机完成对应的运算&lt;/p&gt;
&lt;h4 id=&#34;231-调度scheduling&#34;&gt;2.3.1 调度（Scheduling）&lt;/h4&gt;
&lt;p&gt;调度就是根据我们的硬件资源和算子的计算顺序对算子的部署进行合理安排。一个安排的方案就是调度方案&lt;/p&gt;
&lt;p&gt;目前已有的调度算法有ASAP（越早越好），ALAP（越晚越好），List（优先级驱动调度），SDC（System of Difference Constraints）&lt;/p&gt;
&lt;h4 id=&#34;232-资源绑定resource-binding&#34;&gt;2.3.2 资源绑定（Resource Binding）&lt;/h4&gt;
&lt;p&gt;就是将调度方案中的算子与具体的硬件资源进行绑定&lt;/p&gt;
&lt;h1 id=&#34;chapter4-标准单元库的设计流程与eda&#34;&gt;Chapter4 标准单元库的设计流程与EDA&lt;/h1&gt;
&lt;h2 id=&#34;1-标准单元库standard-cell-library是什么&#34;&gt;1 标准单元库（Standard Cell Library）是什么？&lt;/h2&gt;
&lt;p&gt;standard cell是数字VLSI设计中的基本组件（砖头），比如基本逻辑门（与或非等），Flip-Flop寄存器，MUX多路选择器、加法器等。&lt;/p&gt;
&lt;p&gt;标准单元库就是符合某种生产或设计工艺的标准的标准单元，这些信息由芯片制造厂商提供，基于他们提供的Process Design Kit（ PDK）文件，可以在逻辑综合工具与布局布线工具中对PPA指标等进行优化&lt;/p&gt;
&lt;h2 id=&#34;2-为什么针对设计进行standard-cell-library优化&#34;&gt;2 为什么针对设计进行Standard Cell Library优化&lt;/h2&gt;
&lt;p&gt;因为针对不同应用有不同的功耗、面积需求，需要不同的优化&lt;/p&gt;
&lt;h2 id=&#34;3-标准单元库定制的基本流程&#34;&gt;3 标准单元库定制的基本流程&lt;/h2&gt;
&lt;h3 id=&#34;30-主要的优化目标与形式&#34;&gt;3.0 主要的优化目标与形式&lt;/h3&gt;
&lt;p&gt;主要目标：缩小面积、适配驱动能力与负载、实现更低的输入到输出的延时与更低的逻辑功耗&lt;/p&gt;
&lt;p&gt;主要形式：&lt;strong&gt;面积方面&lt;/strong&gt;：实现Diffusion共享、外部引脚消除；&lt;strong&gt;时序方面&lt;/strong&gt;：通过内部信号传递，实现更短的走线；&lt;strong&gt;功耗方面&lt;/strong&gt;：减小不必要的驱动要求&lt;/p&gt;
&lt;h3 id=&#34;31-确定工艺约束条件&#34;&gt;3.1 确定工艺约束条件&lt;/h3&gt;
&lt;p&gt;对标准单元进行工艺条件约束后，可以与其他标准单元兼容，且能够交给光刻机生产&lt;/p&gt;
&lt;h4 id=&#34;311-cell高度height&#34;&gt;3.1.1 cell高度（Height）&lt;/h4&gt;
&lt;p&gt;高度一般可以用通过多少根横向金属走线进行衡量&lt;/p&gt;
&lt;h4 id=&#34;312-cell跨行数row&#34;&gt;3.1.2 cell跨行数（Row）&lt;/h4&gt;
&lt;p&gt;定制单元是否跨行，跨多少都需要说明。不过针对这种单元的EDA工具链支持得不是很好，主要在学术界有比较多的尝试&lt;/p&gt;
&lt;h4 id=&#34;313-cell各层走线限制密度与方向&#34;&gt;3.1.3 cell各层走线限制（密度与方向）&lt;/h4&gt;
&lt;p&gt;每一个标准单元是由很多半导体工艺层堆叠而来的，每一层有不同的功能&lt;/p&gt;
&lt;h4 id=&#34;314-cell输入输出数目逻辑综合限制&#34;&gt;3.1.4 cell输入输出数目（逻辑综合限制）&lt;/h4&gt;
&lt;p&gt;某个标准单元的定制，一般要设置输入输出的数目限制&lt;/p&gt;
&lt;h3 id=&#34;32-确定目标逻辑函数&#34;&gt;3.2 确定目标逻辑函数&lt;/h3&gt;
&lt;p&gt;明确定制逻辑单元的功能如何，主要考虑组合逻辑&lt;/p&gt;
&lt;h4 id=&#34;321-什么是对于特定应用特定约束下有ppa收益的局部逻辑网表&#34;&gt;3.2.1 什么是对于特定应用、特定约束下，有PPA收益的局部逻辑网表？&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;出现频率：当一个定制单元能在对应的设计中大量使用时，能够让效果更明显。可以用Frequent Subgraph Mining（FSM）算法找到这些子电路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序/面积/功耗的特点：这些特点会被用于定义“有效”的定制&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;322-相同逻辑功能的逻辑网表存在多样性&#34;&gt;3.2.2 相同逻辑功能的逻辑网表存在多样性&lt;/h4&gt;
&lt;p&gt;实现相同功能的网表可能有很不一样的PPA指标。&lt;/p&gt;
&lt;h3 id=&#34;33-确定spice网表&#34;&gt;3.3 确定SPICE网表&lt;/h3&gt;
&lt;p&gt;在晶体管层面进行设计&lt;/p&gt;
&lt;p&gt;可以基于逻辑表达式构建CMOS网络。主要的优化PPA的方法有：增大晶体管尺寸，逐级加大尺寸，重新安排输入，重组逻辑结构等。&lt;/p&gt;
&lt;p&gt;最终晶体管的尺寸、连接关系，可以在SPICE文件中进行描述&lt;/p&gt;
&lt;h3 id=&#34;34-版图生成&#34;&gt;3.4 版图生成&lt;/h3&gt;
&lt;p&gt;VLSI电路是经过多道工艺流程、在不同层面堆叠进行实现的。不同的工艺层包含不同的功能&lt;/p&gt;
&lt;h4 id=&#34;341-设计规则&#34;&gt;3.4.1 设计规则&lt;/h4&gt;
&lt;h4 id=&#34;342-可布线性&#34;&gt;3.4.2 可布线性&lt;/h4&gt;
&lt;p&gt;版图生成的常用算法是模拟退火、MILP、SMT、机器学习等&lt;/p&gt;
&lt;h3 id=&#34;35-参数提取与liberty文件生成&#34;&gt;3.5 参数提取与Liberty文件生成&lt;/h3&gt;
&lt;p&gt;为了能够将定制单元整合入上下游的逻辑综合、布局布线EDA工具，需要有Liberty文件。这个文件中记录啦每个标准单元的功能、面积、电容参数、引脚、各种情况下的延时与功耗等&lt;/p&gt;
&lt;h2 id=&#34;4-自动化搜索与迭代&#34;&gt;4 自动化搜索与迭代&lt;/h2&gt;
&lt;p&gt;自动生成可供参考的定制标准单元，可以显著提高设计效率&lt;/p&gt;
&lt;h1 id=&#34;chapter5-布局算法怎么实现芯片的核舟记&#34;&gt;Chapter5 布局算法怎么实现芯片的“核舟记”？&lt;/h1&gt;
&lt;h2 id=&#34;1-布局的概述&#34;&gt;1 布局的概述&lt;/h2&gt;
&lt;h3 id=&#34;11-布局的基本定义&#34;&gt;1.1 布局的基本定义&lt;/h3&gt;
&lt;p&gt;主要就是将逻辑综合生成的门级网表，排布到一个矩形区域内。这样一个布局要确保后续的布线、工艺检查等步骤的可行性。布局有一系列的评价指标，如面积（Area），走线长度（Wirelength），关键路径延时长度（Critical Path Delay，CPD），功耗（Power）等。&lt;/p&gt;
&lt;p&gt;ASIC的设计方法有基于Standard Cell的定制和完全定制（Full Custom）。&lt;/p&gt;
&lt;p&gt;FPGA是一种可编程的ASIC可以在制造后重新配置。与ASIC相比，FPGA主要增加了电路布局的离散性限制，每个器件必须映射到FPGA已有的组件上。FPGA布局的芯片上各类资源的分布是不均匀的。FPGA上合法化（legalization）是指把电路设计中的实例映射到FPGA的组件上&lt;/p&gt;
&lt;h3 id=&#34;12-布局基本流程&#34;&gt;1.2 布局基本流程&lt;/h3&gt;
&lt;h4 id=&#34;121-时序分析与线长评估timing-analysiswirelength-evaluation&#34;&gt;1.2.1 时序分析与线长评估（Timing Analysis/Wirelength Evaluation）&lt;/h4&gt;
&lt;p&gt;布线之前，要在布局阶段评估布线时走线长度与质量或时序质量。&lt;/p&gt;
&lt;h4 id=&#34;122-初始版图大致规划floorplanningchip-planning&#34;&gt;1.2.2 初始版图大致规划（Floorplanning/Chip Planning）&lt;/h4&gt;
&lt;p&gt;将整个电路划分为几个大块（Partitioning），决定这几个大块之间的相对位置。&lt;/p&gt;
&lt;h4 id=&#34;123-时序线长驱动的全局布局&#34;&gt;1.2.3 时序/线长驱动的全局布局&lt;/h4&gt;
&lt;p&gt;每个实例的位置通过解决线长和时序相关的优化问题来决定（模拟退火，图切割等）。&lt;/p&gt;
&lt;h4 id=&#34;124-器件扩散&#34;&gt;1.2.4 器件扩散&lt;/h4&gt;
&lt;p&gt;根据实例的面积需求和实际版图上某个区域的面积供应，实例会从资源供不应求的区域向其他区域扩散&lt;/p&gt;
&lt;h4 id=&#34;125-器件面积修正&#34;&gt;1.2.5 器件面积修正&lt;/h4&gt;
&lt;p&gt;根据打包可行性和布线拥塞程度，一些标准单元的面积需求会缩小或增加，一些区域的面积供应会增加或减小&lt;/p&gt;
&lt;h4 id=&#34;126-合法化与打包&#34;&gt;1.2.6 合法化与打包&lt;/h4&gt;
&lt;p&gt;每个实例要与其它实例打包到一起，根据某些指标映射到一个确切位置，让某些指标最优化&lt;/p&gt;
&lt;h4 id=&#34;127-细致布局&#34;&gt;1.2.7 细致布局&lt;/h4&gt;
&lt;p&gt;基于全局布局，微调各个器件的位置，对目标函数进行进一步的优化&lt;/p&gt;
&lt;h2 id=&#34;2-布局的各个主要环节相关功能&#34;&gt;2 布局的各个主要环节相关功能&lt;/h2&gt;
&lt;h3 id=&#34;21-线长与时序评估&#34;&gt;2.1 线长与时序评估&lt;/h3&gt;
&lt;p&gt;线长与时序是布局问题中最重要的两个问题。线长作为时序的一种近似。线长越短，时序越好&lt;/p&gt;
&lt;h4 id=&#34;211-线长模型&#34;&gt;2.1.1 线长模型&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;布局中，我们会用一些布线模式去近似实际布线器的走线。半周线长（half-perimeter wirelength，HPWL）是最常用的布线模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把线长“数值函数化”，从而方便我们的数学建模。可以直接用类似遗传算法或者模拟退火算法的布局算法进行函数求解&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;212-时序评估&#34;&gt;2.1.2 时序评估&lt;/h4&gt;
&lt;p&gt;时序分析需要确保，每个被时钟触发的信号，都能从其引脚除法、在下一个时钟触发前、经过一系列逻辑电路和走线抵达目标引脚。&lt;/p&gt;
&lt;p&gt;首先要创建时序图（Timing Graph），其中每个电路的实例构成图中的节点（Timing node），创建时序边（Timing edge）连接每一个发出信号的引脚以及接受信号的引脚。从而将电路转化为有向无环图（Directed Acyclic Graph，DAG）&lt;/p&gt;
&lt;h3 id=&#34;22-初始版图大致计划&#34;&gt;2.2 初始版图大致计划&lt;/h3&gt;
&lt;h4 id=&#34;221-网表切分netlist-partitioning&#34;&gt;2.2.1 网表切分（Netlist Partitioning）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;最小化切分后的子图、团之间的连接数&lt;/li&gt;
&lt;li&gt;每个子图的面积/资源需求小于某个设计约束&lt;/li&gt;
&lt;li&gt;尽可能平衡每个子图的资源或面积大小&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;222-电路块布局cluster-placement&#34;&gt;2.2.2 电路块布局（Cluster Placement）&lt;/h4&gt;
&lt;p&gt;切分后就可以决定这些Cluster的位置，经典算法是Slicing tree算法，还有模拟退火算法&lt;/p&gt;
&lt;h3 id=&#34;23-时序线长驱动的全局布局&#34;&gt;2.3 时序/线长驱动的全局布局&lt;/h3&gt;
&lt;p&gt;全局布局通常启动一个迭代优化的过程，目前较新的是基于解析模型进行数值求解&lt;/p&gt;
&lt;h4 id=&#34;231-布局问题的数学解析模型&#34;&gt;2.3.1 布局问题的数学解析模型&lt;/h4&gt;
&lt;p&gt;优化布局问题是希望最小化线长或者优化时序，可以利用Bound2Bound近似将HPWL近似为二次函数，再利用DREAMPlacer将器件摊开&lt;/p&gt;
&lt;h4 id=&#34;232-布局问题数值求解&#34;&gt;2.3.2 布局问题数值求解&lt;/h4&gt;
&lt;p&gt;得到解析数学模型后就可以放进数学求解器进行求解了&lt;/p&gt;
&lt;h3 id=&#34;24-器件扩散&#34;&gt;2.4 器件扩散&lt;/h3&gt;
&lt;p&gt;要把实例合理得散开，从资源不足的地方散到资源充足的地方。&lt;/p&gt;
&lt;h3 id=&#34;25-器件面积修正&#34;&gt;2.5 器件面积修正&lt;/h3&gt;
&lt;h4 id=&#34;251-兼容性面积修正&#34;&gt;2.5.1 兼容性面积修正&lt;/h4&gt;
&lt;p&gt;有些实例要打包在一起的前提是必须共享某些信号，所以相当于不互相兼容的实例，他们所需的面积/资源变大了&lt;/p&gt;
&lt;h4 id=&#34;252-拥塞面积修正&#34;&gt;2.5.2 拥塞面积修正&lt;/h4&gt;
</description>
      
    </item>
    
    <item>
      <title>旅游记Ⓒ2020</title>
      <link>https://shangkunli.github.io/post/life/%E6%97%85%E6%B8%B8%E8%AE%B0/%E6%97%85%E6%B8%B8%E8%AE%B02020/</link>
      <pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/life/%E6%97%85%E6%B8%B8%E8%AE%B0/%E6%97%85%E6%B8%B8%E8%AE%B02020/</guid>
      
        <description>&lt;p&gt;闲下来总是喜欢出去走走&lt;/p&gt;
&lt;p&gt;这里保存了我从2020年开始到过的地方的记录&lt;/p&gt;
&lt;p&gt;✈️ Click the Link to See More.&lt;/p&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
&lt;table border=&#34;1&#34;&gt;
    &lt;tr&gt;
      &lt;th style=&#34;text-align: center;&#34;&gt;Year&lt;/th&gt; 
      &lt;th style=&#34;text-align: center;&#34;&gt;Destination&lt;/th&gt; 
      &lt;th style=&#34;text-align: center;&#34;&gt;Brief Introduction&lt;/th&gt; 
      &lt;th style=&#34;text-align: center;&#34;&gt;Month/Year&lt;/th&gt; 
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;2020&lt;/td&gt;
        &lt;td&gt;上海&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;https://shangkunli.github.io/post/life/旅游记/2020-10-01-海湾国家森林公园上海中心大厦/&#34;&gt;趁着小长假去了海湾国家森林公园和上海中心大厦&lt;a/&gt;&lt;/td&gt;
        &lt;td&gt;10/2020&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td rowspan=&#34;5&#34;&gt;2021&lt;/td&gt;
        &lt;td&gt;重庆&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;https://shangkunli.github.io/post/life/旅游记/2021-02-25-山城步道鹅岭/&#34;&gt;有味道的山城步道，和老游去鹅岭上闲逛&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;02/2021&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;杭州&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;https://shangkunli.github.io/post/life/旅游记/2021-03-18-杭州-西湖畔/&#34;&gt;说走就走的西湖畔&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;03/2021&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;南京&lt;/td&gt;
        &lt;td&gt;&lt;a href=&#34;https://shangkunli.github.io/post/life/旅游记/2021-04-05-南京南京/&#34;&gt;几个大男孩的快乐&lt;/a&gt;&lt;/td&gt;
        &lt;td&gt;04/2021&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;杭州&lt;/td&gt;
        &lt;td&gt;有所期待的 淳安·千岛湖&lt;/td&gt;
        &lt;td&gt;09/2021&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;上海&lt;/td&gt;
        &lt;td&gt;来了这么久，还是头一回去MAP和上博&lt;/td&gt;
        &lt;td&gt;10/2021&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td rowspan=&#34;7&#34;&gt;2022&lt;/td&gt;
        &lt;td&gt;苏州&lt;/td&gt;
        &lt;td&gt;依稀留存着小时候的记忆，也算是故地重游了&lt;/td&gt;
        &lt;td&gt;01/2022&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;上海&lt;/td&gt;
        &lt;td&gt;长兴岛 等一个自然而然的晴天，然后一起去海边～&lt;/td&gt;
        &lt;td&gt;02/2022&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;上海&lt;/td&gt;
        &lt;td&gt;郁金香公园，偶遇扛着大炮的公园大爷&lt;/td&gt;
        &lt;td&gt;02/2022&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;大理&lt;/td&gt;
        &lt;td&gt;那就向西去大理吧，这真的是一个很治愈的地方，在这里也认识了很有趣的人&lt;/td&gt;
        &lt;td&gt;06/2022&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;丽江&lt;/td&gt;
        &lt;td&gt;如果说大理很宁静，那丽江就是探寻人间烟火的绝佳去处&lt;/td&gt;
        &lt;td&gt;06/2022&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;上海&lt;/td&gt;
        &lt;td&gt;在大陆的东边，看日出；在海昌海洋公园的暴走&lt;/td&gt;
        &lt;td&gt;10/2022&lt;/td&gt;
    &lt;/tr&gt;
  &lt;tr&gt;
        &lt;td&gt;上海&lt;/td&gt;
        &lt;td&gt;如果想看狗子开Party，那就来徐汇滨江&lt;/td&gt;
        &lt;td&gt;10/2022&lt;/td&gt;
    &lt;/tr&gt;
  &lt;tr&gt;
        &lt;td rowspan=&#34;1&#34;&gt;2023&lt;/td&gt;
        &lt;td&gt;南京&lt;/td&gt;
        &lt;td&gt;六朝古都，千年金陵&lt;/td&gt;
        &lt;td&gt;03/2023&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
</description>
      
    </item>
    
    <item>
      <title>Hugo-Jane主题个性化记录</title>
      <link>https://shangkunli.github.io/post/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/2023-4-21-hugo-jane%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Fri, 21 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/2023-4-21-hugo-jane%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%B0%E5%BD%95/</guid>
      
        <description>&lt;p&gt;本博客的主要目的是用于记录jane主题的一些个性化需求的更改，以防后续查询&lt;/p&gt;
&lt;h1 id=&#34;个性化字体&#34;&gt;个性化字体&lt;/h1&gt;
&lt;p&gt;打开&lt;code&gt;themes/jane/assets/sass/_variables.scss&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;在Global部分，设置全文章的字体。如下设置后在macOS中，中英文都能更换为目标字体。在Windows中，只有英文能够更换为Times New Roman字体&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-1&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-1&#34;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-2&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-2&#34;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-3&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-3&#34;&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-4&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-4&#34;&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-5&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-5&#34;&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-6&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-6&#34;&gt;6&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-7&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-7&#34;&gt;7&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-0-8&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-0-8&#34;&gt;8&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Default line height for all type. `$global-lineheight` is 24px while `$global-font-size` is 16px.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#bb60d5&#34;&gt;$global-lineheight&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#40a070&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#40a070&#34;&gt;.5&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;!default&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Font family of the site.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#bb60d5&#34;&gt;$global-font-family&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;Times New Roman&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;Source Sans Pro&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;Helvetica Neue&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt; Arial&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#d55537;font-weight:bold&#34;&gt;sans-serif&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;!default&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Serif font family of the site.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#bb60d5&#34;&gt;$global-serif-font-family&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;Times New Roman&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt;Athelas&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt; STHeiti&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt; Microsoft Yahei&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#d55537;font-weight:bold&#34;&gt;serif&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;!default&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在Header部分，设置如下的字体，可以将Shangkun&amp;rsquo;s Blog在各种浏览器及系统中均设为Times New Roman字体&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-1-1&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-1-1&#34;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-1-2&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-1-2&#34;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;// Font family of the logo.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#bb60d5&#34;&gt;$logo-font-family&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#4070a0&#34;&gt;&amp;#39;Times New Roman&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt;LiSu&lt;span style=&#34;color:#666&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#d55537;font-weight:bold&#34;&gt;sans-serif&lt;/span&gt; &lt;span style=&#34;color:#007020;font-weight:bold&#34;&gt;!default&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;个性化排版&#34;&gt;个性化排版&lt;/h1&gt;
&lt;p&gt;打开&lt;code&gt;/themes/jane/assets/sass/_partial/_post/_content.scss&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;在如下代码块中加入&lt;code&gt;text-align&lt;/code&gt;内容，即可设置对齐的相关参数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-2-1&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-2-1&#34;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-2-2&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-2-2&#34;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-2-3&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-2-3&#34;&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span style=&#34;white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34; id=&#34;hl-2-4&#34;&gt;&lt;a style=&#34;outline:none;text-decoration:none;color:inherit&#34; href=&#34;#hl-2-4&#34;&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#062873;font-weight:bold&#34;&gt;p&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;//font-size: 1em;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#60a0b0;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#4070a0&#34;&gt;text-align&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#d55537;font-weight:bold&#34;&gt;justify&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>书影档案</title>
      <link>https://shangkunli.github.io/post/life/%E4%B9%A6%E5%BD%B1%E6%A1%A3%E6%A1%88/%E4%B9%A6%E5%BD%B1%E6%A1%A3%E6%A1%88/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/life/%E4%B9%A6%E5%BD%B1%E6%A1%A3%E6%A1%88/%E4%B9%A6%E5%BD%B1%E6%A1%A3%E6%A1%88/</guid>
      
        <description>&lt;h1 id=&#34;书影档案&#34;&gt;书影档案&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;书名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;评分&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;短评&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;to be added&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;jjjjjjjjjjjjjjjjjjjjnhkjhkhjkhjkhkj23&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;23e2ewdwd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
    <item>
      <title>可重构计算-第6章</title>
      <link>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter6/</link>
      <pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter6/</guid>
      
        <description>&lt;h1 id=&#34;第6章-计算密集型与控制密集型重构计算&#34;&gt;第6章 计算密集型与控制密集型重构计算&lt;/h1&gt;
&lt;h2 id=&#34;61-计算密集型与控制密集型应用的特征与举例&#34;&gt;6.1 计算密集型与控制密集型应用的特征与举例&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算密集型：计算部分所需的执行时间是其总体时间的主要部分&lt;/li&gt;
&lt;li&gt;数据密集型：IO访问时间和数据搬移时间是其总体时间的主要部分&lt;/li&gt;
&lt;li&gt;控制密集型：控制流所需的执行时间是其总体执行时间的主要部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算密集型和数据密集型适合并行处理。计算密集型将应用划分为多个独立的子任务，并行流水执行；数据密集型将数据分成多个独立的部分。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hpac.cs.umu.se/people/springer/cuda_dwarf_seminar.pdf&#34;&gt;&lt;strong&gt;伯克利分类方法&lt;/strong&gt;&lt;/a&gt;：十三种典型的分类方法&lt;/p&gt;
&lt;h2 id=&#34;62-可重构计算处理器的设计方法&#34;&gt;6.2 可重构计算处理器的设计方法&lt;/h2&gt;
&lt;p&gt;高效处理器系统的两个主流发展方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并行化设计：增加并行运算单元数目，加速较高并行度的程序段&lt;/li&gt;
&lt;li&gt;差异化与专用化设计：各个子模块针对专用领域或应用类型进行差异优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对计算密集型和控制密集型，对应不同的可重构计算处理器设计：&lt;/p&gt;
&lt;h3 id=&#34;621-面向计算密集型应用的硬件设计&#34;&gt;6.2.1 面向计算密集型应用的硬件设计&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面向计算密集型应用的可重构控制器的设计&lt;/p&gt;
&lt;p&gt;只含有简单的控制流，配置只需要简单地顺序加载，PFSM也简单，无需特别优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向计算密集型应用的可重构数据通路的设计&lt;/p&gt;
&lt;p&gt;包含一个运算单元阵列和运算单元之间的互连&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运算单元阵列的并行化设计
&lt;ul&gt;
&lt;li&gt;指令级并行：主要体现在运算单元的配置上，多个运算单元组成运算单元阵列&lt;/li&gt;
&lt;li&gt;数据级并行：支持矢量化的计算方式&lt;/li&gt;
&lt;li&gt;任务级并行：多个协同的运算单元阵列实现，把多个线程分别映射到各个阵列上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;运算单元的功能差异化和专用化设计
&lt;ul&gt;
&lt;li&gt;不同粒度的运算单元阵列&lt;/li&gt;
&lt;li&gt;删除部分运算单元中使用率低的功能，得到基本单元的&lt;strong&gt;异构形式&lt;/strong&gt;，能量效率高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;互连结构的并行化设计
&lt;ul&gt;
&lt;li&gt;过于灵活的互连面积功耗代价较大，降低可重构计算处理器的能效；不灵活的互连会降低阵列内部有效通信的带宽，降低计算性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;互连结构的功能专用化设计
&lt;ul&gt;
&lt;li&gt;可以将运算单元的某些类型的算子分离出来，独立成一类专用化的运算单元；例如单目算子延时小，可以加入互连结构，成为专用化的单目运算单元&lt;/li&gt;
&lt;li&gt;将阵列的层间通路由具备简单的数据通路，变成一种异构的计算单元，计算分布式设计到互连中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;622-面向控制密集型应用的硬件设计&#34;&gt;6.2.2 面向控制密集型应用的硬件设计&lt;/h3&gt;
&lt;p&gt;该类应用由大量条件分支和循环结构组成，条件判断的计算量和执行的计算量差不多，控制流和数据通路的通信量较大&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件跳转语句&lt;/li&gt;
&lt;li&gt;条件分支语句&lt;/li&gt;
&lt;li&gt;循环语句&lt;/li&gt;
&lt;li&gt;程序调用语句&lt;/li&gt;
&lt;li&gt;程序终止语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消除控制依赖关系，加速互斥和串行的语句是提高控制密集型应用性能的关键&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少指令跳转可以提高执行控制密集型应用的性能&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可重构数据通路设计&lt;/p&gt;
&lt;p&gt;可将控制流转换为数据流，从而在数据通路上实现控制。比如FPGA的配置不能切换，控制流完全在数据通路上实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;条件执行技术&lt;/p&gt;
&lt;p&gt;将控制依赖转变为数据依赖&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE12.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;加载A和B，但是顺序执行时根据P的结果无效化一条语句&lt;/p&gt;
&lt;p&gt;完全条件执行方式：为每个语句增添条件执行拓展；部分条件执行方式：为某种语句添加条件拓展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;完全条件执行的设计方法&lt;/p&gt;
&lt;p&gt;if_conversion算法，把所有条件分支内部的指令替换为条件执行语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部分条件执行的设计方法&lt;/p&gt;
&lt;p&gt;只增加一个条件数据转移指令或者选择指令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推测执行技术&lt;/p&gt;
&lt;p&gt;强制对分支结构内部的语句使用无条件执行的方式，虽然这些语句有可能不需要执行，但是该技术假定他们需要执行，以消除他们与条件语句的依赖关系&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重构控制器设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通用处理器&lt;/p&gt;
&lt;p&gt;通用可重构计算处理器拥有足够的灵活性，但效率和性能不高。基于指令的FSM是串行的，对于多分支或嵌套分支结构，指令流会以串行的方式执行条件判断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;专用集成电路&lt;/p&gt;
&lt;p&gt;PFSM的ASIC设计：基于LUT（look-up table）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;63-计算密集型任务和控制密集型任务的映射方法&#34;&gt;6.3 计算密集型任务和控制密集型任务的映射方法&lt;/h2&gt;
&lt;h3 id=&#34;631-计算密集型任务相关的映射方法&#34;&gt;6.3.1 计算密集型任务相关的映射方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;问题抽象&lt;/p&gt;
&lt;p&gt;DFG进行映射时的情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不足区域：计算区域过小&lt;/li&gt;
&lt;li&gt;线性区域：将完成划分的算子区域直接映射到硬件阵列上&lt;/li&gt;
&lt;li&gt;冗余区域：较大的算子区域配置部分的计算任务&lt;/li&gt;
&lt;li&gt;理想区域：输入输出少，计算量大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;映射方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区域增长：对于不足区域，改变循环，扩展计算区域&lt;/li&gt;
&lt;li&gt;矢量化：对于线性区域&lt;/li&gt;
&lt;li&gt;虚拟化：对应冗余区域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;632-控制密集型任务相关的映射方法&#34;&gt;6.3.2 控制密集型任务相关的映射方法&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title>随想录</title>
      <link>https://shangkunli.github.io/post/life/%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%9A%8F%E6%83%B3%E5%BD%95/</link>
      <pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/life/%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%9A%8F%E6%83%B3%E5%BD%95/</guid>
      
        <description>&lt;h1 id=&#34;随想录&#34;&gt;随想录&lt;/h1&gt;
&lt;p&gt;to be added&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>可重构计算-第5章</title>
      <link>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter5/</link>
      <pubDate>Sat, 11 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter5/</guid>
      
        <description>&lt;h1 id=&#34;第5章-动态重构与部分重构&#34;&gt;第5章 动态重构与部分重构&lt;/h1&gt;
&lt;h2 id=&#34;51-动态重构与部分重构的概念&#34;&gt;5.1 动态重构与部分重构的概念&lt;/h2&gt;
&lt;h3 id=&#34;511-静态重构&#34;&gt;5.1.1 静态重构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;比如FPGA，由于采用细粒度的查找表单元，配置文件巨大，导致超长重构时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;512-动态重构&#34;&gt;5.1.2 动态重构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;比如CGRA，CGRA粒度大配置信息量小，可以在短时间内完成功能重构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;513-部分重构&#34;&gt;5.1.3 部分重构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据通路在空间上被划分为多个区域， 每个区域被重构成特定的功能引擎来执行特定的计算任务
&lt;ul&gt;
&lt;li&gt;静态部分重构：重构时非配置区要停下来&lt;/li&gt;
&lt;li&gt;动态部分重构：重构时非配置区可正常执行（CGRA）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-配置信息的组织管理与高速缓存&#34;&gt;5.2 配置信息的组织、管理与高速缓存&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;配置粒度&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次配置完成的可重构数据通路中被划分出的区域规模&lt;/li&gt;
&lt;li&gt;细粒度配置：一次只完成一个运算单元的配置&lt;/li&gt;
&lt;li&gt;中粒度配置：一次完成一块区域的配置（一行、一列，1/2阵列等）&lt;/li&gt;
&lt;li&gt;粗粒度配置：一次完成整个阵列的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;521-细粒度配置中配置信息的组织管理与缓存&#34;&gt;5.2.1 细粒度配置中配置信息的组织、管理与缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;配置链结构：按固定的顺序，从配置接口开始链接各个运算单元内的配置寄存器，配置信息在配置链中逐级传递，直到匹配目标运算单元&lt;/li&gt;
&lt;li&gt;配置链结构的重构时间取决于配置信息传到距离接口最远的配置单元的传输时间&lt;/li&gt;
&lt;li&gt;垂直配置链+水平配置链：先匹配行，再匹配列&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;522-中粒度配置中配置信息的组织管理与缓存&#34;&gt;5.2.2 中粒度配置中配置信息的组织、管理与缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以运算阵列中的行为单位，依次配置&lt;/li&gt;
&lt;li&gt;可以方便地实现DFG图到阵列的映射&lt;/li&gt;
&lt;li&gt;配置流程：
&lt;ul&gt;
&lt;li&gt;读出步配置信息，缓存在步寄存器中&lt;/li&gt;
&lt;li&gt;行配置信息对步配置信息到行配置信息的载入进行控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;523-粗粒度配置中配置信息的组织管理与缓存&#34;&gt;5.2.3 粗粒度配置中配置信息的组织、管理与缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;配置信息从配置存储器中读出后，直接被写入运算单元内的配置寄存器中&lt;/li&gt;
&lt;li&gt;完全动态重构：运算单元阵列在运算的过程中每一时钟周期都对阵列功能进行重构&lt;/li&gt;
&lt;li&gt;完全动态重构产生较高的配置功耗，占40%左右。可以通过压缩连续周期执行相同算子的配置，来减少配置功耗&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;53-计算数据的组织管理与高速缓存&#34;&gt;5.3 计算数据的组织、管理与高速缓存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数据传输面临存储墙问题&lt;/li&gt;
&lt;li&gt;现代通用处理器采用处理器与内存之间的多级cache结构&lt;/li&gt;
&lt;li&gt;可重构系统面临的存储墙问题更加严峻，因为并行计算能力更强&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;531-细粒度可重构阵列的管理与缓存结构&#34;&gt;5.3.1 细粒度可重构阵列的管理与缓存结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以FPGA为例，FPGA的结构中可以采用少量多块的离散数据缓存结构，提高数据访问速度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;532-粗粒度可重构阵列的管理与缓存结构&#34;&gt;5.3.2 粗粒度可重构阵列的管理与缓存结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据预取：可以将数据传输与阵列配置 or 计算过程并行执行&lt;/li&gt;
&lt;li&gt;随着计算速度的提高，数据预取成为了流水线中的关键路径&lt;/li&gt;
&lt;li&gt;有的采用与通用处理器类似的方法，增加多层数据缓存结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;533-层次化数据缓存结构&#34;&gt;5.3.3 层次化数据缓存结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;计算数据的有效组织与管理可以提高数据吞吐量，减小外村带宽对阵列计算效率的制约&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重构系统的存储结构：片外主存，阵列之间的全局存储，阵列独享的共享存储，阵列内的运算单元独享的局部存储&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE11.png&#34; alt=&#34;截屏2023-02-10 21.21.41&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;片外主存：存储输入数据，中间结果，最终结果&lt;/li&gt;
&lt;li&gt;全局存储：存储阵列之间的交互数据，存储可重构阵列与系统访存控制器（DMAC）之间的交互数据&lt;/li&gt;
&lt;li&gt;共享存储：存储阵列的可重构结果及少量中间结果&lt;/li&gt;
&lt;li&gt;局部存储：避免访存冲突，保证确定的访存时延，保证阵列的计算流水线不会被不确定的访存时延打断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>可重构计算-第4章</title>
      <link>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter4/</link>
      <pubDate>Sun, 05 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter4/</guid>
      
        <description>&lt;h1 id=&#34;第4章-可重构计算处理器编译系统&#34;&gt;第4章 可重构计算处理器编译系统&lt;/h1&gt;
&lt;p&gt;输入应用程序，生成可重构计算处理器控制的控制码和数据通路的配置信息&lt;/p&gt;
&lt;h2 id=&#34;41-可重构计算处理器编译框架与流程&#34;&gt;4.1 可重构计算处理器编译框架与流程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;编译器首先对代码进行变换和优化，生成中间表达式IR，然后将中间表达式映射到可重构计算阵列上。再对任务进行时域划分，最后生成控制码和配置信息&lt;/li&gt;
&lt;li&gt;三项关键技术：&lt;strong&gt;代码变化及优化&lt;/strong&gt;，&lt;strong&gt;任务时域划分&lt;/strong&gt;，&lt;strong&gt;映射配置的生成&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;42-可重构计算处理器代码变化及优化&#34;&gt;4.2 可重构计算处理器代码变化及优化&lt;/h2&gt;
&lt;h3 id=&#34;421-指令级变换&#34;&gt;4.2.1 指令级变换&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;树高度缩减&lt;/p&gt;
&lt;p&gt;对运算重新排序，减少运算树的高度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运算强度缩减&lt;/p&gt;
&lt;p&gt;将一种运算转化为一系列成本更低的运算。比如乘法转换为移位或加减操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码转移：上移与下移&lt;/p&gt;
&lt;p&gt;把同种表达式或者子表达式的重复运算放在常用路径上，缩减代码规模&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;422-循环级变换&#34;&gt;4.2.2 循环级变换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;减少循环开销的同时增加指令级并行的可能性&lt;/li&gt;
&lt;li&gt;循环展开的两种策略：
&lt;ul&gt;
&lt;li&gt;循环完全展开，只适用小循环&lt;/li&gt;
&lt;li&gt;最内层循环展开&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;43-可重构计算处理器任务划分&#34;&gt;4.3 可重构计算处理器任务划分&lt;/h2&gt;
&lt;h3 id=&#34;431-任务划分概述&#34;&gt;4.3.1 任务划分概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当某个任务所需的计算资源超过目标硬件所能提供的计算资源时，需要对该任务进行划分&lt;/li&gt;
&lt;li&gt;本书中指的主要是时域划分&lt;/li&gt;
&lt;li&gt;划分的原则：
&lt;ul&gt;
&lt;li&gt;完整性：划分前后功能一致&lt;/li&gt;
&lt;li&gt;独立性：划分不存在死锁，比如两个部分的数据存在相互依赖&lt;/li&gt;
&lt;li&gt;有效性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;432-时域划分算法的相关研究&#34;&gt;4.3.2 时域划分算法的相关研究&lt;/h3&gt;
&lt;p&gt;需要一个控制器来实现对配置信息流的控制，并且需要一定的机制来使不同配置信息进行数据通信&lt;/p&gt;
&lt;h2 id=&#34;44-可重构计算处理器任务调度&#34;&gt;4.4 可重构计算处理器任务调度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将运算操作在时间和硬件资源上进行安排&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;45-可重构计算处理器映射配置生成&#34;&gt;4.5 可重构计算处理器映射配置生成&lt;/h2&gt;
&lt;h3 id=&#34;451-寄存器分配&#34;&gt;4.5.1 寄存器分配&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;并非所有变量都要寄存器，部分可以通过连线来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;452-运算到硬件资源的映射&#34;&gt;4.5.2 运算到硬件资源的映射&lt;/h3&gt;
&lt;h3 id=&#34;453-内存映射优化&#34;&gt;4.5.3 内存映射优化&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数组到内存资源的映射及划分&lt;/p&gt;
&lt;p&gt;将不同的数据分布到不同的内存中，可以提升每个时钟内循环操作的数目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存访问并行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存控制器的定制&lt;/p&gt;
&lt;p&gt;创建专门的硬件产生地址和对数据打包、拆包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据项的打包和拆包&lt;/p&gt;
&lt;p&gt;可以在非标准的数据类型格式下定义操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>可重构计算-第3章</title>
      <link>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter3/</link>
      <pubDate>Sat, 04 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter3/</guid>
      
        <description>&lt;h1 id=&#34;第3章-可重构计算处理器硬件架构&#34;&gt;第3章 可重构计算处理器硬件架构&lt;/h1&gt;
&lt;h2 id=&#34;31-可重构数据通路设计&#34;&gt;3.1 可重构数据通路设计&lt;/h2&gt;
&lt;h3 id=&#34;311-可重构计算单元设计&#34;&gt;3.1.1 可重构计算单元设计&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;粒度选择&lt;/p&gt;
&lt;p&gt;FPGA为单比特粒度，但配置的面积代价和时间代价很大，无法动态配置。粒度越小越灵活，但需要付出更大的面积和配置时间；粒度越小则配置速度越快，但影响算法映射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存选择&lt;/p&gt;
&lt;p&gt;合理的寄存器位置有利于实现流水线等算法加速执行手段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算功能选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算术：加减乘除&lt;/li&gt;
&lt;li&gt;比较：大于小于等于大于等于&lt;/li&gt;
&lt;li&gt;逻辑：与或非异或同或&lt;/li&gt;
&lt;li&gt;移位：逻辑左右移，算术左右移&lt;/li&gt;
&lt;li&gt;异构：一个大而全的计算单元中，一些功能的使用率很低，这种情况下应该对单元进行适当裁剪以得到基本计算单元的异构形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;312-可重构路由单元设计&#34;&gt;3.1.2 可重构路由单元设计&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;各种输入输出的选择单元，构成了可重构路由单元&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;313-阵列接口单元的设计&#34;&gt;3.1.3 阵列接口单元的设计&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可重构阵列面临存储墙的问题：存储器的接口带宽有限&lt;/li&gt;
&lt;li&gt;减少接口带宽的需求，在阵列内部设计缓存，数据不再频繁通过外部接口&lt;/li&gt;
&lt;li&gt;提高接口带宽上限，可以压缩数据：比如输入数据位宽小于接口时，可以将多个数据拼接共用接口&lt;/li&gt;
&lt;li&gt;合理的FIFO值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;314-可重构阵列缓存设计&#34;&gt;3.1.4 可重构阵列缓存设计&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存储系统的好坏决定并行系统吞吐量计算的性能，&lt;strong&gt;分布式存储&lt;/strong&gt;是提升可重构计算处理器吞吐效率的方法之一&lt;/li&gt;
&lt;li&gt;在外部存储器和计算阵列FIFO之间，设计缓存结构
&lt;ul&gt;
&lt;li&gt;按照数据变化的频率分类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;常数和立即数缓存结构&lt;/p&gt;
&lt;p&gt;常数和立即数倍存到阵列专门设置的缓存结构中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量的堆寄存器结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;短变量在每个周期变化时反复使用；长变量则相隔数个周期再用到&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以增加额外的数据通路，实现阵列扩展：可以通过堆寄存器将前一次结果存下来，后面一起输出，这样输出结果会大于阵列宽度，相当于扩大了阵列宽度&lt;/li&gt;
&lt;li&gt;缓存中间数据，在两次配置之间传递数据&lt;/li&gt;
&lt;li&gt;插入空拍，提高流水线效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量的边界存储结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量的阵列外部缓存结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在外部寄存器和计算阵列接口之间放入的缓存单元&lt;/li&gt;
&lt;li&gt;针对规则的数据变换使用存储器和控制逻辑可以提高性能&lt;/li&gt;
&lt;li&gt;多种数据变换操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;32-可重构控制器设计&#34;&gt;3.2 可重构控制器设计&lt;/h2&gt;
&lt;h3 id=&#34;321-配置结构定义&#34;&gt;3.2.1 配置结构定义&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置系统的层次化设计&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE9.png&#34; alt=&#34;截屏2023-01-28 20.15.46&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算子功能编码研究&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定码长，码长由操作的总数目决定&lt;/li&gt;
&lt;li&gt;为了降低电路的功耗，对运算单元内部各主要模块做门控电源或时钟&lt;/li&gt;
&lt;li&gt;为了降低配置端翻转次数，根据算子的转移概率进行huffman编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阵列时序模型研究&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阵列同步配置信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;阵列的两种同步方式
&lt;ul&gt;
&lt;li&gt;在每个子单元的子任务序列中最后一个任务结束后，需要对各个子单元进行同步，以便执行下一个综合任务&lt;/li&gt;
&lt;li&gt;子任务之间存在数据时序依赖关系，需要对某几个任务进行同步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子单元的两种同步时机
&lt;ul&gt;
&lt;li&gt;后同步&lt;/li&gt;
&lt;li&gt;前同步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步控制涉及模块
&lt;ul&gt;
&lt;li&gt;子单元配置字缓存起&lt;/li&gt;
&lt;li&gt;同步控制器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步信息的描述方式和同步流程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;322-配置执行方式&#34;&gt;3.2.2 配置执行方式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE10.png&#34; alt=&#34;截屏2023-01-28 20.36.41&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;323-配置缓存设计&#34;&gt;3.2.3 配置缓存设计&lt;/h3&gt;
&lt;h2 id=&#34;33-可重构数据通路与控制器的耦合关系&#34;&gt;3.3 可重构数据通路与控制器的耦合关系&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;嵌入模式：数据通路在控制器内部实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协处理器模式：数据通路和控制器同一个芯片内连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立芯片模式：数据通路在控制器芯片外实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般情况，离控制器越远，对算法的加速效果越好，但是配置的代价也越大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>About</title>
      <link>https://shangkunli.github.io/about/</link>
      <pubDate>Fri, 03 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/about/</guid>
      
        <description>&lt;link rel=&#34;stylesheet&#34; href=&#34;https://shangkunli.github.io/css/hugo-easy-gallery.css&#34; /&gt;
&lt;div class=&#34;box&#34;&gt;
&lt;figure  itemprop=&#34;associatedMedia&#34;
  itemscope itemtype=&#34;http://schema.org/ImageObject&#34; &gt;
    &lt;div class=&#34;img&#34;&gt;
      &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://shangkunli.github.io/imag/%e7%ae%80%e4%bb%8b/IMG_0001.JPG&#34; /&gt;
    &lt;/div&gt;
    &lt;a href=&#34;https://shangkunli.github.io/imag/%e7%ae%80%e4%bb%8b/IMG_0001.JPG&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;
      &lt;figcaption&gt;&lt;h4&gt;摄于云南大理&lt;/h4&gt;
      &lt;/figcaption&gt;
  &lt;/figure&gt;
&lt;/div&gt;

&lt;p&gt;Hi! I am &lt;strong&gt;Shangkun Li&lt;/strong&gt;, welcome to my homepage. I am an undergraduate student in the Department of Physics, Fudan University. Although my major is physics, my research interests are mainly in the field of digital circuit design. Through elective courses, auditing classes, reading books, and project practice, I have accumulated knowledge related to microelectronics. Currently, I am conducting research internships under the guidance of professors from the &lt;a href=&#34;https://sme.fudan.edu.cn&#34;&gt;School of Microelectronics&lt;/a&gt;, Fudan University and the &lt;a href=&#34;https://ece.hkust.edu.hk&#34;&gt;ECE department&lt;/a&gt; of &lt;a href=&#34;https://hkust.edu.hk&#34;&gt;HKUST&lt;/a&gt;. My research direction mainly focuses on EDA and reconfigurable computing.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;This is my CV:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/%E7%AE%80%E4%BB%8B/%E4%B8%AD%E6%96%87%E7%89%88CV.pdf&#34;&gt;中文版简历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/%E7%AE%80%E4%BB%8B/CV_English_Version.pdf&#34;&gt;CV-English Version&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;honors-and-awards&#34;&gt;Honors and Awards&lt;/h2&gt;
&lt;p&gt;Academic Year 2021-2022, &lt;strong&gt;National Scholarship&lt;/strong&gt; (Top 1%)&lt;/p&gt;
&lt;p&gt;Academic Year 2021-2022, &lt;strong&gt;Pacemaker to Merit Student&lt;/strong&gt; (10 out of all undergraduates in Fudan University)&lt;/p&gt;
&lt;p&gt;Academic Year 2020-2021, &lt;strong&gt;The First Prize Scholarship&lt;/strong&gt; (Top 5%)&lt;/p&gt;
&lt;p&gt;Academic Year 2020-2021, Merit Student&lt;/p&gt;
&lt;p&gt;Aug 2021, Grand Prize of the 12th China Undergraduate Physics Tournament (&lt;strong&gt;Ranking 2nd in China&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;Dec 2022, Third Prize of the 8th China Undergraduate Physics Experiment Competition&lt;/p&gt;
&lt;h2 id=&#34;publications&#34;&gt;Publications&lt;/h2&gt;
&lt;p&gt;Hope there will be something soon.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E7%AE%80%E4%BB%8B/pdf_%E7%A0%B4%E5%A4%A7%E9%98%B2.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;news-about-me&#34;&gt;News about me&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://news.fudan.edu.cn/2023/0205/c5a133834/page.htm&#34;&gt;复旦大学：本科生如何开启科研之路？复旦标兵们这样做→&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://news.fudan.edu.cn/2021/0831/c5a109937/page.htm&#34;&gt;复旦大学：重要物理赛事捷报频传 复旦大学物理学系师生合力获佳绩&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/5L9K5NGK-5G6w1R6nhbJTA&#34;&gt;复旦大学物理学系：学生集体及个人标兵称号&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>可重构计算-第1章</title>
      <link>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter1/</link>
      <pubDate>Thu, 02 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter1/</guid>
      
        <description>&lt;h1 id=&#34;第1章-计算技术发展史&#34;&gt;第1章 计算技术发展史&lt;/h1&gt;
&lt;h2 id=&#34;11-计算技术引言&#34;&gt;1.1 计算技术引言&lt;/h2&gt;
&lt;p&gt;进位概念推动了计数法的发展&lt;/p&gt;
&lt;h3 id=&#34;111-史前时代电子计算机之前&#34;&gt;1.1.1 史前时代——电子计算机之前&lt;/h3&gt;
&lt;h3 id=&#34;112-第一代电子计算机电子管计算机&#34;&gt;1.1.2 第一代电子计算机——电子管计算机&lt;/h3&gt;
&lt;h3 id=&#34;113-第二代电子计算机晶体管计算机&#34;&gt;1.1.3 第二代电子计算机——晶体管计算机&lt;/h3&gt;
&lt;h3 id=&#34;114-第三代电子计算机集成电路计算机&#34;&gt;1.1.4 第三代电子计算机——集成电路计算机&lt;/h3&gt;
&lt;h3 id=&#34;115-第四代电子计算机大规模集成电路计算机&#34;&gt;1.1.5 第四代电子计算机——大规模集成电路计算机&lt;/h3&gt;
&lt;h2 id=&#34;12-经典计算体系结构&#34;&gt;1.2 经典计算体系结构&lt;/h2&gt;
&lt;p&gt;计算分为通用计算，如Intel i3/5/7，和专用计算，如显卡芯片，MP3解码芯片等&lt;/p&gt;
&lt;h3 id=&#34;121-计算体系结构设计因素&#34;&gt;1.2.1 计算体系结构设计因素&lt;/h3&gt;
&lt;p&gt;体系结构的设计要考虑技术、性能、功耗和成本等因素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;技术因素&lt;/p&gt;
&lt;p&gt;硅工艺。芯片面积决定成本；特征尺寸决定及程度、延时和功耗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能因素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功耗因素&lt;/p&gt;
&lt;p&gt;翻转功耗，漏电功耗和短路功耗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面积因素&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;122-冯诺依曼体系和哈佛体系结构&#34;&gt;1.2.2 冯诺依曼体系和哈佛体系结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;冯诺依曼体系将运算器与存储器分开，导致运算器与存储器之间的流量与存储器相比非常小&lt;/li&gt;
&lt;li&gt;在运算器和存储器间的快取内存缓解了冯诺依曼瓶颈的问题&lt;/li&gt;
&lt;li&gt;分支预测算法的建立也帮助缓和了问题&lt;/li&gt;
&lt;li&gt;哈佛体系将程序指令存储与数据存储分开&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;123-并行计算体系结构&#34;&gt;1.2.3 并行计算体系结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指令并行，循环并行，线程并行，程序并行&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;SISD结构（单指令流单数据流）&lt;/li&gt;
&lt;li&gt;SIMD结构（单指令流多数据流）&lt;/li&gt;
&lt;li&gt;MISD结构（多指令流单数据流）&lt;/li&gt;
&lt;li&gt;MIMD结构（多指令流多数据流）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;124-多核和阿姆达尔定律&#34;&gt;1.2.4 多核和阿姆达尔定律&lt;/h3&gt;
&lt;p&gt;多核绕开了单核频率墙的问题&lt;/p&gt;
&lt;h2 id=&#34;13-半导体技术发展的挑战&#34;&gt;1.3 半导体技术发展的挑战&lt;/h2&gt;
&lt;h3 id=&#34;131-芯片复用技术需求&#34;&gt;1.3.1 芯片复用技术需求&lt;/h3&gt;
&lt;p&gt;芯片的工艺线成本和设计费用在不断增加&lt;/p&gt;
&lt;h3 id=&#34;132-低功耗技术需求&#34;&gt;1.3.2 低功耗技术需求&lt;/h3&gt;
&lt;p&gt;当芯片特征尺寸缩小，漏电急剧增加，功耗密度上升，存在&lt;strong&gt;功耗墙&lt;/strong&gt;的问题&lt;/p&gt;
&lt;h3 id=&#34;133-存储技术瓶颈&#34;&gt;1.3.3 存储技术瓶颈&lt;/h3&gt;
&lt;p&gt;DRAM的提高速度远小于处理器速度提升速度。出现&lt;strong&gt;存储墙&lt;/strong&gt;问题&lt;/p&gt;
&lt;h2 id=&#34;14-可重构计算技术的历史背景&#34;&gt;1.4 可重构计算技术的历史背景&lt;/h2&gt;
&lt;p&gt;强调资源的复用，在静态情况下，采用类似ASIC的设计追求高性能；在动态情况下，通过改变功能配置，适应不同应用的要求&lt;/p&gt;
&lt;p&gt;在基于近平衡态物理的硅微电子技术发展速度明显放缓，摩尔定律失效，硅微电子的创新将主要依赖于芯片设计方法学的进步&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>可重构计算-第2章</title>
      <link>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter2/</link>
      <pubDate>Thu, 02 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter2/</guid>
      
        <description>&lt;h1 id=&#34;第2章-可重构计算&#34;&gt;第2章 可重构计算&lt;/h1&gt;
&lt;h2 id=&#34;21-可重构计算基本概念和原理&#34;&gt;2.1 可重构计算基本概念和原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;：能够实现算法到计算引擎的空间映射，并在被制造成集成电路后还具备定制能力的计算组织形式被称为可重构计算&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可重构计算的特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硅实现以后计算功能仍旧可以按需改变，区别于传统的专用集成电路&lt;/li&gt;
&lt;li&gt;能实现很大程度的算法到计算引擎的空间映射&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1986年xilnix开发出第一块FPGA芯片，但FPGA的资源浪费比较严重，所需的编程数据较多，用它实现的一些功能模块性能难以满足要求，逐渐出现了粗粒度的处理单元&lt;/p&gt;
&lt;h2 id=&#34;22-可重构计算特征与分类&#34;&gt;2.2 可重构计算特征与分类&lt;/h2&gt;
&lt;h3 id=&#34;221-可重构计算特征与分类&#34;&gt;2.2.1 可重构计算特征与分类&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE5.png&#34; alt=&#34;截屏2023-01-27 10.55.29&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统处理器是时域计算，具有通用、固定的结构，听从指令的命令并执行相应的操作&lt;/li&gt;
&lt;li&gt;可以改进为专用指令集处理器ASIP处理，加速处理过程&lt;/li&gt;
&lt;li&gt;如图b所示，在硬件上执行该算法，可以大大加速该计算过程&lt;/li&gt;
&lt;li&gt;如果要计算问题1和问题2，则需要改变硬件的接线结构。FPGA必是静态重构的，需要重新上电；动态可重构计算可以在运行时改变硬件功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;222-可重构计算的分类&#34;&gt;2.2.2 可重构计算的分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多数可重构计算处理器具有以下特征
&lt;ul&gt;
&lt;li&gt;硬件结构上由可重构数据通路和可重构控制器组成。可重构数据通路多采用基本运算单元组成的阵列式结构&lt;/li&gt;
&lt;li&gt;处理器的控制流与数据流分离&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按应用范围划分
&lt;ul&gt;
&lt;li&gt;领域定制可重构计算处理器：针对特定应用范围定制的可重构计算处理器。目前的主要研究成果&lt;/li&gt;
&lt;li&gt;通用可重构计算处理器：支持通用计算的可重构计算处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按粒度划分
&lt;ul&gt;
&lt;li&gt;粒度是指可重构计算处理器数据通路中运算单元的数据位宽度&lt;/li&gt;
&lt;li&gt;粒度越大可重构计算处理器所需的配置信息就越少，处理器的重构速度就越快，但功能灵活性也相应越低&lt;/li&gt;
&lt;li&gt;细粒度：不超过4比特 FPGA——1比特&lt;/li&gt;
&lt;li&gt;粗粒度：大于等于4比特 CGRA——8～16比特&lt;/li&gt;
&lt;li&gt;中粒度：这一说法不常见&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按重构的时间特性划分
&lt;ul&gt;
&lt;li&gt;静态重构：只能在可重构计算处理器的数据通路进行计算之前对其进行功能重构。FPGA&lt;/li&gt;
&lt;li&gt;动态重构：可重构计算处理器的数据通路在计算过程中也能进行功能重构。CGRA&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按重构的空间特性划分
&lt;ul&gt;
&lt;li&gt;部分重构：数据通路可以在空间上划分为多个区域，每个区域可以重构成特定的功能引擎，而不会影响其他区域的当前状态&lt;/li&gt;
&lt;li&gt;整体重构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;23-可重构计算处理器模型&#34;&gt;2.3 可重构计算处理器模型&lt;/h2&gt;
&lt;h3 id=&#34;231-可重构计算处理器硬件架构组成&#34;&gt;2.3.1 可重构计算处理器硬件架构组成&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可重构数据通路 RCD&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE6.png&#34; alt=&#34;截屏2023-01-27 11.27.24&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置接口从RCC获取控制信号和配置信息：解析配置信息，配置运算单元阵列，调度任务&lt;/li&gt;
&lt;li&gt;运算单元阵列：像ASIC一样由数据流驱动执行&lt;/li&gt;
&lt;li&gt;数据接口：对外部数据的访问和写回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重构控制器 RCC&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE7.png&#34; alt=&#34;截屏2023-01-27 11.33.03&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置接口：用于给可重构数据通路发送配置信息和控制信号&lt;/li&gt;
&lt;li&gt;配置管理单元：接受来自外部的配置信息，解析得到控制信号和配置字&lt;/li&gt;
&lt;li&gt;存储器：存储内部配置信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;232-可重构计算处理器编译器结构&#34;&gt;2.3.2 可重构计算处理器编译器结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编译器提供RCC中运行的控制码和RCD的配置信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重构计算处理器编译技术：将应用程序通过任务划分、代码变化、任务调度及映射过程，将应用程序生成可重构计算处理器中可重构控制器的控制码和可重构硬件的配置信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE8.png&#34; alt=&#34;截屏2023-01-27 10.55.29&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对输入的应用程序进行代码分析，将代码划分为软件运行代码和硬件执行代码。针对各部分程序代码进行编译处理，生成RCC的控制码和RCD的配置信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;24-可重构计算处理器发展现状与趋势&#34;&gt;2.4 可重构计算处理器发展现状与趋势&lt;/h2&gt;
&lt;h3 id=&#34;241-可重构计算处理器硬件架构研究&#34;&gt;2.4.1 可重构计算处理器硬件架构研究&lt;/h3&gt;
&lt;p&gt;目前在高能效计算：多媒体领域、软件无线电领域、密码学领域都有应用&lt;/p&gt;
&lt;h3 id=&#34;242-可重构计算处理器编译器研究&#34;&gt;2.4.2 可重构计算处理器编译器研究&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;LEAP编译工具：面向LEAP粗粒度可重构阵列处理器的编译工具。仅针对特定的循环进行编译&lt;/li&gt;
&lt;li&gt;国内任务编译关键技术点研究：国内尚处于起步阶段&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>可重构计算-第0章</title>
      <link>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter0/</link>
      <pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/reconfigurable_computing/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97chapter0/</guid>
      
        <description>&lt;h1 id=&#34;第0章-绪论&#34;&gt;第0章 绪论&lt;/h1&gt;
&lt;h2 id=&#34;01-计算与集成电路&#34;&gt;0.1 计算与集成电路&lt;/h2&gt;
&lt;h3 id=&#34;011-计算机与冯诺依曼体系&#34;&gt;0.1.1 计算机与冯诺依曼体系&lt;/h3&gt;
&lt;h3 id=&#34;012-集成电路与摩尔定律&#34;&gt;0.1.2 集成电路与摩尔定律&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;摩尔定律&lt;/li&gt;
&lt;li&gt;迪纳德定律&lt;/li&gt;
&lt;li&gt;目前影响集成电路集成度和性能进一步提升的主要因素：集成工艺，功耗和由此产生的热&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;02-计算架构&#34;&gt;0.2 计算架构&lt;/h2&gt;
&lt;h3 id=&#34;021-冯-诺伊曼体系架构的变形&#34;&gt;0.2.1 冯-诺伊曼体系架构的变形&lt;/h3&gt;
&lt;p&gt;​	如果一个系统的运行受到程序的控制，就是广义的处理器；如果不受程序的控制，就是专用处理器&lt;/p&gt;
&lt;h3 id=&#34;022-通用计算架构&#34;&gt;0.2.2 通用计算架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE1.png&#34; alt=&#34;截屏2023-01-22 20.38.13&#34;&gt;&lt;/p&gt;
&lt;p&gt;​	控制器在外部时钟的控制下，依据数据通路回送的状态和程序，决定向数据通路发送什么样的控制向量。数据通路根据控制器发来的控制向量决定要进行的运算，运算过程会使用输入的数据并将产生的结果送到系统外输出。
​    1. &lt;strong&gt;专用集成电路架构&lt;/strong&gt;：与上面相比，这一架构的最大差别是系统的行为都确定，控制向量确定
​        2. &lt;strong&gt;通用处理器架构&lt;/strong&gt;：控制向量根据状态和程序实时产生&lt;/p&gt;
&lt;h2 id=&#34;03-数字系统的高层次综合技术&#34;&gt;0.3 数字系统的高层次综合技术&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;高层次综合的目标：将不同工程师写的HDL描述统一到某个优化架构上，从而保证设计的优化程度&lt;/li&gt;
&lt;li&gt;高层次综合的核心理念：将硬件描述映射到一个优化的架构，从而获得更优的设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;031-基本概念&#34;&gt;0.3.1 基本概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据从寄存器出发，经过运算再回到寄存器的过程被称为寄存器传输。使用HDL进行的电路设计又称为寄存器传输级设计（Register transfer level），即RTL设计。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据流图DFG与控制流图CFG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源复用的概念&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;032-数据通路设计&#34;&gt;0.3.2 数据通路设计&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;算子调度&lt;/strong&gt;：确定每个操作执行的时间位置，以及所需的运算资源的类型和数量。算子调度直接关系到设计电路系统的性能和代价，曾是高层次综合研究的重点。提出了多种算法，可划分为尝试型算法和穷举型算法。力量引导调度算法：算子调度的实质是将各个控制步中同一类运算的数量尽可能平均，以达到运算资源复用最大化，进而减少资源的使用量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源分配&lt;/strong&gt;：为每个操作指定一个具体的运算资源，为每个变量分配一个存储单元，并提供存储单元与资源之间的连接网络
&lt;ul&gt;
&lt;li&gt;寄存器优化：核心目标是减少寄存器的数量。如果一个寄存器的存活时间与其他一个或多个寄存器的死亡时间重叠，则该寄存器的功能可以被其他寄存器替代&lt;/li&gt;
&lt;li&gt;运算资源分配：因为每个算子可能会涉及多个运算资源，因此我们需要对每个算子分配具体的运算资源，不同的分配方案对应的连线网络结构和代价不同。资源分配也产生过多种算法，包括贪婪算法，全通图算法，基于距离的资源分配算法。&lt;/li&gt;
&lt;li&gt;连线网络生成：连线网络提供存储单元与运算资源之间的信号通路
&lt;ol&gt;
&lt;li&gt;总线架构：优点是灵活性与可扩展性，缺点是延迟时间对系统性能提升不明显&lt;/li&gt;
&lt;li&gt;点对点架构：牺牲灵活性和可扩展性换来更低的整体延迟，在ASIC中被更多地采用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;控制码生成与优化：控制码由控制器提供，数据通路按照控制器提供的控制码运行。微码压缩问题
1. 控制码生成：首先对多路选择开关控制端进行编码，然后按照控制步一步一步生成
2. 控制码优化：减少控制码的量，从而减少所需存储器的容量，降低控制器的复杂度。可以减少码字数量，或者缩短码长。减少码字数量：找出相同的码字；缩短码长：通过全过程中不同端口步之间的关系将端口连接起来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;033-控制器设计&#34;&gt;0.3.3 控制器设计&lt;/h3&gt;
&lt;p&gt;控制器是一个FSM&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;控制器的FSM：状态的定义不同，设计出的FSM不同&lt;/li&gt;
&lt;li&gt;基于状态的控制码：将状态码与对应状态关联起来&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;034-小结&#34;&gt;0.3.4 小结&lt;/h3&gt;
&lt;p&gt;了解了高层次综合方法的脉络：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从硬件的行为设计描述出发&lt;/li&gt;
&lt;li&gt;通过算子调度、资源分配、控制码生成等步骤&lt;/li&gt;
&lt;li&gt;得到一个运算资源优化的数据通路&lt;/li&gt;
&lt;li&gt;确定控制器的架构并完成设计&lt;/li&gt;
&lt;li&gt;数据通路和控制器构成系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;04-可重构计算技术&#34;&gt;0.4 可重构计算技术&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE2.png&#34; alt=&#34;图2&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，将数据通路和控制器设想为完全可编程的，也就是说，从任意一个存储器的输出端出发，经过输入端连接线网络可以到达任意一个ALU的输入端，ALU的结果可以经过输出端网络到达任意一个存储器。这样的ALU网络就是完全可重构的。控制器对应的FSM也是受外部程序控制的，可编程的&lt;/p&gt;
&lt;p&gt;FPGA的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它是静态重构，即FPGA的内部结构取决于上电时读取的配置信息，运行过程中不能改变&lt;/li&gt;
&lt;li&gt;FPGA的LUT（look-up table）不可以被复用&lt;/li&gt;
&lt;li&gt;FPGA能提供给用户使用的有效逻辑门数量不过50-100万个，而规模却有上千万个逻辑门&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过构建可重构数据通路和可编程控制器，可以有效克服FPGA的缺点，实现运行过程中的实时重构，允许资源复用&lt;/p&gt;
&lt;h3 id=&#34;041-可重构计算处理器&#34;&gt;0.4.1 可重构计算处理器&lt;/h3&gt;
&lt;p&gt;一个可重构数据通路RCD可以按找软件的要求，变换成与之相适应的硬件网络，并实现其功能，这被称为可重构计算&lt;/p&gt;
&lt;p&gt;可重构计算也要求控制器时可编程或可重构的，即可重构控制器RCC，即可编程有限状态机PFSM&lt;/p&gt;
&lt;p&gt;控制数据通路的控制码也要求随时生成，因此还需要一个编译器，根据软件生成控制码和控制流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可重构计算处理器架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RCD与基于PFSM的RCC一起构成了可重构计算处理器(RCP)。&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE3.png&#34; alt=&#34;截屏2023-01-24 17.09.43&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shangkunli.github.io/imag/%E5%8F%AF%E9%87%8D%E6%9E%84%E8%AE%A1%E7%AE%97/%E5%9B%BE4.png&#34; alt=&#34;截屏2023-01-24 17.09.43&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RCD与基于PFSM的RCC一起构成了可重构计算处理器(RCP)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个软件经过编译器编译，就可以产生配置信息，用于生成PFSM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在多个ALU的系统中，指令系统限制了灵活性。因此RCP不再依赖指令，而是生成软件配置信息，再由RCC通过配置信息对RCD控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个理想的RCD应拥有尽可能多的ALU，且这些ALU之间的互连架构可以改变&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算阵列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一维、二维、三维的ALU阵列架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ALU阵列的计算过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在RCD中，如果使用一维ALU阵列，则ALU向量可以逐步执行软件。软件的各操作在编译器中实现算子调度、寄存器优化、资源分配，并生成数据通路架构和控制码（配置信息）&lt;/li&gt;
&lt;li&gt;一个具备N行ALU的阵列可以并行地支持N个任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重构计算中不需要物理上生成数据通路，但是仍然要依据RCD结构，构建一个虚拟的数据通路VD，VD包含RCD中用到的元件&lt;/li&gt;
&lt;li&gt;运行给定的软件，还需要由RCC向RCD提供一个FSM，因此，编译器还需要生成一个虚拟FSM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PFSM&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RCC包含状态机和存储器两个部分。状态机包含当前状态，下一个状态以及转移条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;042-可重构计算处理器的编译技术&#34;&gt;0.4.2 可重构计算处理器的编译技术&lt;/h3&gt;
&lt;p&gt;编译器：将高级编程语言写成的程序/软件翻译成计算机的执行码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可重构计算处理器的编译器架构
&lt;ul&gt;
&lt;li&gt;可重构计算处理器的编译器将程序/软件翻译成配置信息，包含数据流、控制流和配置信息&lt;/li&gt;
&lt;li&gt;高级语言的大部分功能在现有可重构计算处理器的编译器上都支持，但递归调用与指针的实现还在摸索中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码优化
&lt;ul&gt;
&lt;li&gt;优化的关键是保证代码的正确性，故对代码的语义分析必须正确。因此针对可重构计算处理器时需要加一些特殊语句来指导编译&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任务划分
&lt;ul&gt;
&lt;li&gt;编译器要根据ALU阵列的大小对程序进行划分，形成一系列的子任务，让可重构计算处理器逐块完成运算&lt;/li&gt;
&lt;li&gt;任务划分的一个难点是处理分支，防止死锁&lt;/li&gt;
&lt;li&gt;另一个要求是子任务间的通信尽可能减少，也就是不同子任务间的连线数量最小化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任务调度与资源分配
&lt;ul&gt;
&lt;li&gt;如果可重构计算处理器中包含多个ALU阵列，任务调度就要确定哪些任务可以并行，以便确定要同时运行的ALU阵列数量&lt;/li&gt;
&lt;li&gt;然后进行资源分配，当存在多个ALU时，需要确定每个子任务使用的是哪个ALU阵列。这将影响数据传送的代价以及对ALU阵列配置过程产生影响，导致功耗增加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子任务中的算子调度和资源分配
&lt;ul&gt;
&lt;li&gt;在一定条件下，一个ALU也可以被其他子任务TASK共享，从而提高资源的使用效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VFSM的生成
&lt;ul&gt;
&lt;li&gt;如果将任务划分产生的一系列子任务TASK作为状态，则可以构建一个以子任务为状态、子任务间依赖关系为边的FSM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;043-小结&#34;&gt;0.4.3 小结&lt;/h3&gt;
&lt;p&gt;可重构计算借用了许多高层次综合的概念与方法。&lt;/p&gt;
&lt;p&gt;探索可重构计算的原因主要为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进一步提高计算性能的需求。 通常的冯诺依曼架构采用指令，而执行一条指令的时间中只有很小一部分用于真正计算，所以人们期望改变架构，减少指令执行中准备计算的时间&lt;/li&gt;
&lt;li&gt;在提升性能的同时降低功耗，提升计算效能，即提升单位功耗下的性能&lt;/li&gt;
&lt;li&gt;经济因素。在22nm之后，随着其他成本，比如研发费用的增加，单个逻辑门的成本下降空间非常有限。这将导致专用集成电路的发展受阻。因此，通过编程或者重构来实现不同功能的通用处理芯片就成为一个必然的选择&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>CompPhys: Differentiation and Intergration</title>
      <link>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-differentiation-and-intergration/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-differentiation-and-intergration/</guid>
      
        <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;这一章节主要介绍数值微分与积分的方法&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Computational_Physics-differentiation-integration-4.pdf&#34;&gt;Computational Physics: Differentiation and Intergration&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;求解问题&#34;&gt;求解问题&lt;/h1&gt;
&lt;h2 id=&#34;题目说明&#34;&gt;题目说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compute the derivative of $f(x) = sinx$ at $x = π/3$ using the Richardson extrap- olation algorithm. Start with h = 1 and find the number of rows in the Richardson table required to estimate the derivative with six significant decimal digits. Output the Richardson table.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Radial wave function of the 3s orbital is:&lt;/p&gt;
&lt;p&gt;$$R_{3s} = \frac{1}{9\sqrt3} ×(6−6\rho+\rho^2)×Z^{3/2}×e^{-\rho/2}$$&lt;/p&gt;
&lt;p&gt;· r = radius expressed in atomic units (1 Bohr radius = 52.9 pm)&lt;/p&gt;
&lt;p&gt;· e = 2.71828 approximately&lt;/p&gt;
&lt;p&gt;· Z = effective nuclear charge for that orbital in that atom&lt;/p&gt;
&lt;p&gt;· ρ = 2Zr/n where n is the principal quantum number (3 for the 3s orbital)&lt;/p&gt;
&lt;p&gt;Compute $$\int_0^{40}|R_{3s}|^2r^2dr $$for Si atom (Z = 14) with Simpson’s rule using two different radial grids:&lt;/p&gt;
&lt;p&gt;(1)Equalspacinggrids: $$r[i]=(i−1)h$$  ;  $$i=1,···,N$$ (trydifferentN)&lt;/p&gt;
&lt;p&gt;(2) A nonuniform integration grid, more finely spaced at small r than at large r:&lt;/p&gt;
&lt;p&gt;$$r[i] = r_0(e^{t[i]} − 1)$$; $$t[i] = (i − 1)h$$;$$ i = 1,· · · , N$$ (One typically choose$$ r_0 = 0.0005$$ a.u., try different N)&lt;/p&gt;
&lt;p&gt;(3) Find out which one is more eﬀicient, and discuss the reason.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Assignment_05.pdf&#34;&gt;Differentiation and Intergration Documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ShangkunLi/Computational_Physics/tree/main/Assignment%2005&#34;&gt;Differentiation and Intergration Source Code&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CompPhys: FFT</title>
      <link>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-fft/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-fft/</guid>
      
        <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;这一章节主要介绍傅立叶变换的相关算法&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Computational_Physics-FFT-5.pdf&#34;&gt;CompPhys: FFT&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;求解问题&#34;&gt;求解问题&lt;/h1&gt;
&lt;h2 id=&#34;题目说明&#34;&gt;题目说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$$\hat H =-\frac{\hbar^2}{2m}\frac{\partial^2}{\partial x^2} +V(x)$$. Periodic potential $$V(x)=V(x+a)$$.
Using FFT, find the lowest three eigenvalues of the eigenstates that satisfy $$\psi_i=\psi_i(x+1)$$&lt;/p&gt;
&lt;p&gt;$$U_0=2eV, L_w=0.9nm, L_B=0.1nm, a=1nm$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Download the file called sunspots.txt, which contains the observed number of sunspots on the Sun for each month since January 1749.&lt;/p&gt;
&lt;p&gt;Write a program to calculate the Fourier transform of the sunspot data and then make a graph of the magnitude squared $$|c_k|^2$$ of the Fourier coeﬀicients as a function of k—also called the power spectrum of the sunspot signal. You should see that there is a noticeable peak in the power spectrum at a nonzero value of k. Find the approximate value of k to which the peak corresponds. What is the period of the sine wave with this value of k?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Assignment_06.pdf&#34;&gt;FFT Documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ShangkunLi/Computational_Physics/tree/main/Assignment%2006&#34;&gt;FFT Source Code&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CompPhys: Find Root</title>
      <link>https://shangkunli.github.io/post/comp_phys/find_root/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/comp_phys/find_root/</guid>
      
        <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;这一章节主要介绍寻找方程根与函数极小值的方法（如梯度下降法）&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Computational_Physics-find-root-1.pdf&#34;&gt;Computational Physics: Find Root&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;求解问题&#34;&gt;求解问题&lt;/h1&gt;
&lt;h2 id=&#34;题目说明&#34;&gt;题目说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;求解实系数方程$$𝑎𝑥^2+𝑏𝑥+𝑐+0$$的解。要求:系数𝑎, 𝑏, 𝑐为程序执行时键盘输入，𝑎, 𝑏, 𝑐为任意实数，所有的解均输出到屏幕。&lt;/li&gt;
&lt;li&gt;24 点游戏是儿时玩的主要益智类游戏之一，玩法为:从一副扑克中抽取 4 张牌，对 4 张牌使用加减乘除中的任何方法，使计算结果为 24。例如， 2,3,4,6，通过(((4+6)-2)*3) =24，最快算出24者胜。请 采用 Fortran90 编程求解 24 点游戏的解。&lt;/li&gt;
&lt;li&gt;Sketch the function $$𝑥^2−5𝑥+3=0$$:
(1) Determine the two positive roots to 4 decimal places using the bisection method.
(2) Take the two roots that you found in the previous question (accurate to 4 decimals) and “polish them up” to 14 decimal places using the Newton-Raphson method.
(3) Determine the two positive roots to 14 decimal places using the hybrid method.&lt;/li&gt;
&lt;li&gt;Search for the minimum of the function 𝑔(𝑥, 𝑦) = sin(𝑥 + 𝑦) + cos (𝑥 + 2𝑦) in the whole place&lt;/li&gt;
&lt;li&gt;Determine 𝑚(𝑡) the reduced magnetization as a function of reduced temperature for simple materials. $$𝑚(𝑡) = 𝑡𝑎𝑛h(𝑚(𝑡)/𝑡)$$
For a given 𝑡, solve 𝑚, plot 𝑚 as a function of 𝑡.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Assignment_01.pdf&#34;&gt;Find Root Documentation1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Assignment_02.pdf&#34;&gt;Find Root Documentation1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ShangkunLi/Computational_Physics/tree/main/Assignment%2001&#34;&gt;Find Root Source Code1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ShangkunLi/Computational_Physics/tree/main/Assignment%2002&#34;&gt;Find Root Source Code1&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CompPhys: Interpolation</title>
      <link>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-interpolation/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-interpolation/</guid>
      
        <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;这一章节主要介绍插值的相关算法，如牛顿插值法，样条插值法等&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Computational_Physics-Interpolation-3.pdf&#34;&gt;Computational Physics: Interpolation&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;求解问题&#34;&gt;求解问题&lt;/h1&gt;
&lt;h2 id=&#34;题目说明&#34;&gt;题目说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Newton interpolation of:&lt;/p&gt;
&lt;p&gt;(i) 10 equal spacing points of cos x within $$[0, π]$$&lt;/p&gt;
&lt;p&gt;(ii) 10 equal spacing points $$\frac{1}{1+25x^2}$$ within $$[-1,1]$$&lt;/p&gt;
&lt;p&gt;Compare the results with the cubic spline interpolation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The table below gives the temperature T along a metal rod whose ends are kept at fixed constant temperature. The temperature is a function of the distance x along the rod.&lt;/p&gt;
&lt;p&gt;(1)Compute a least-squares, straight-line fit to these data using $$ T (x) = a + bx$$&lt;/p&gt;
&lt;p&gt;(2)Compute a least-squares, parabolic-line fit to these data using $$ T(x) = a+bx+cx^2$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;x/cm&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1.0&lt;/th&gt;
&lt;th&gt;2.0&lt;/th&gt;
&lt;th&gt;3.0&lt;/th&gt;
&lt;th&gt;4.0&lt;/th&gt;
&lt;th&gt;5.0&lt;/th&gt;
&lt;th&gt;6.0&lt;/th&gt;
&lt;th&gt;7.0&lt;/th&gt;
&lt;th&gt;8.0&lt;/th&gt;
&lt;th&gt;9.0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;T/c&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;14.6&lt;/td&gt;
&lt;td&gt;18.5&lt;/td&gt;
&lt;td&gt;36.6&lt;/td&gt;
&lt;td&gt;30.8&lt;/td&gt;
&lt;td&gt;58.2&lt;/td&gt;
&lt;td&gt;60.1&lt;/td&gt;
&lt;td&gt;62.2&lt;/td&gt;
&lt;td&gt;79.4&lt;/td&gt;
&lt;td&gt;99.9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Assignment_04.pdf&#34;&gt;Interpolation Documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ShangkunLi/Computational_Physics/tree/main/Assignment%2004&#34;&gt;Interpolation Source Code&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CompPhys: Matrix</title>
      <link>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-matrix/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-matrix/</guid>
      
        <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;这一章节主要介绍矩阵的相关处理，消元，矩阵分解，特征值问题等&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Computational_Physics-matrix-2.pdf&#34;&gt;Computational Physics: Matrix&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;求解问题&#34;&gt;求解问题&lt;/h1&gt;
&lt;h2 id=&#34;题目说明&#34;&gt;题目说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Prove that the time complexity of the Gaussian elimination algorithm is $$O(N^3)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write a general code to transform a n×m matrix into the REDUCED ROW ECHE-&lt;/p&gt;
&lt;p&gt;LON FORM, and use the code to obtain the RREF of the following matrix.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solve the 1D Schrodinger equation with the potential&lt;/p&gt;
&lt;p&gt;(i) $$V (x) = x^2$$&lt;/p&gt;
&lt;p&gt;(ii) $$V (x) = x^4 − x^2 $$with the variational approach using a Gaussian basis (either fixed widths or fixed centers). Consider the three lowest energy eigenstates.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Assignment_03.pdf&#34;&gt;Matrix Documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ShangkunLi/Computational_Physics/tree/main/Assignment%2003&#34;&gt;Matrix Source Code&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CompPhys: Monte Carlo simulations</title>
      <link>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-monte-carlo-simulations/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-monte-carlo-simulations/</guid>
      
        <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;这一章节主要偏微分方程的数值求解方法&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Computational_Physics-MC-8.pdf&#34;&gt;CompPhys: Monte Carlo simulations&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;求解问题&#34;&gt;求解问题&lt;/h1&gt;
&lt;h2 id=&#34;题目说明&#34;&gt;题目说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The interior of a $d$-dimensional hypersphere of unit radius is defined by the condition $$x_1^2+x_2^2+\dots+x_d^2\le1$$. Write a program that finds the volume of a hypersphere using a Monte Carlo method. Test your program for $$d=2$$ and $$d=3$$ and then calculate the volume for $$d=4$$ and $$d=5$$, compare your results with the exact results.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write a MC code for a 3D Face-Centered Cubic lattice using the Heisenberg spin model (adopt periodic boundary condition). Estimate the ferromagnetic Curie temperature.&lt;/p&gt;
&lt;p&gt;​        $$H=-J \sum\limits_{&amp;lt;i,j&amp;gt;_{NN}}\vec{S_i}\cdot\vec{S_j},\ J=1,\ |\vec{S_i}|=1$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Assignment_09.pdf&#34;&gt;Monte Carlo simulations Documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ShangkunLi/Computational_Physics/tree/main/Assignment%2009&#34;&gt;Monte Carlo simulations Source Code&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CompPhys: Ordinary Differential Equations</title>
      <link>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-ordinary-differential-equations/</link>
      <pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://shangkunli.github.io/post/comp_phys/2023-2-6-compphys-ordinary-differential-equations/</guid>
      
        <description>&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;这一章节主要常微分方程的数值求解方法&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Computational_Physics-ODE-6.pdf&#34;&gt;CompPhys: Ordinary Differential Equations&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;求解问题&#34;&gt;求解问题&lt;/h1&gt;
&lt;h2 id=&#34;题目说明&#34;&gt;题目说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Write a code to numerically solves the motion of a simple pendulum using Euler’s method, midpoint method, RK4, Euler-trapezoidal method (implement these methods by yourself). Plot the angle and total energy as a function of time. Explain the results.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write a code to numerically solves radial Schrödinger equation for:&lt;/p&gt;
&lt;p&gt;$$  \left[-\frac{1}{2}\nabla^2+V(r)\right]\psi( r)=E\psi(r), V( r)=V(r)$$&lt;/p&gt;
&lt;p&gt;​    (1) $$V(r)=-\frac{1}{r}$$ (hydrogen atom)&lt;/p&gt;
&lt;p&gt;​    (2) $$Z_{ion}=0.4000000, C_1=-14.0093922$$&lt;/p&gt;
&lt;p&gt;​		 $$C_2=9.5099073, C_3=-1.7532723, C_4=0.0834586$$&lt;/p&gt;
&lt;p&gt;​        $$ V(r)=-\frac{Z_{ion}}{r}erf\left(\frac{r}{\sqrt{2}r_{loc}}\right)+exp\left[-\frac{1}{2}\left(\frac{r}{r_{loc}}\right)^2\right]$$&lt;/p&gt;
&lt;p&gt;​					$$\times\left[C_1+C_2\left(\frac{r}{r_{loc}}\right)^2+C_3\left(\frac{r}{r_{loc}}\right)^4+C_4\left(\frac{r}{r_{loc}}\right)^6\right]\nonumber $$&lt;/p&gt;
&lt;p&gt;​    Compute and plot the first three eigenstates.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://shangkunli.github.io/pdf/Comp_Phys/Assignment_07.pdf&#34;&gt;Ordinary Differential Equations Documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;source-code&#34;&gt;Source Code&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ShangkunLi/Computational_Physics/tree/main/Assignment%2007&#34;&gt;Ordinary Differential Equations Source Code&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
